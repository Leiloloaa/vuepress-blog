(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{494:function(t,e,n){"use strict";n.r(e);var a=n(21),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"react-面试题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-面试题"}},[t._v("#")]),t._v(" React 面试题")]),t._v(" "),n("p",[t._v("2021.06 出了 React18 Alpha\n")]),t._v(" "),n("p",[t._v("React源码文件指引：https://www.processon.com/view/link/5dd68342e4b001fa2e0c4697")]),t._v(" "),n("h2",{attrs:{id:"什么是-fiber"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-fiber"}},[t._v("#")]),t._v(" 什么是 fiber？")]),t._v(" "),n("p",[t._v("fiber 是链表格式的虚拟dom")]),t._v(" "),n("p",[n("strong",[t._v("为什么需要 fiber？")]),t._v("\n对于大型项目，组件树会很大，这个时候递归遍历的成本就会很高，会造成主线程被持续占用，结果就是主线程的布局、动画等周期性任务就无法立即得到处理，造成视觉上的卡顿，影响用户体验。")]),t._v(" "),n("p",[n("strong",[t._v("为什么是 fiber？")]),t._v("\n以前的虚拟 dom 是数组。因为 js 是单线程，有些操作比较耗时间，为了满足浏览器渲染不卡顿，所以区分为高优先级和低优先级任务，高优先级的先执行（动画、点击、输入等），然后再执行优先级低的。链表有指针，中断操作后，方便返回继续操作。")]),t._v(" "),n("p",[n("strong",[t._v("fiber 生成虚拟dom")])]),t._v(" "),n("p",[n("img",{attrs:{src:"http://66.152.176.25:8000/home/images/diff/fiber.png",alt:""}})]),t._v(" "),n("p",[t._v("每一个 fiber 里面的 return 就是指向它的父节点（看 stateNode）")]),t._v(" "),n("p",[n("img",{attrs:{src:"http://66.152.176.25:8000/home/images/diff/fiber1.png",alt:""}})]),t._v(" "),n("p",[t._v("为什么是 child 而不是 children？因为是链表形式（一个接一个的），而不是数组（一团）。")]),t._v(" "),n("p",[t._v("函数组件和类组件没有dom节点，实例render渲染完成以后才有dom节点子节点才有节点")]),t._v(" "),n("p",[n("img",{attrs:{src:"http://66.152.176.25:8000/home/images/diff/fiber4.png",alt:""}})]),t._v(" "),n("p",[n("img",{attrs:{src:"http://66.152.176.25:8000/home/images/diff/fiber6.png",alt:""}})]),t._v(" "),n("p",[n("img",{attrs:{src:"http://66.152.176.25:8000/home/images/diff/fiber5.png",alt:""}})]),t._v(" "),n("h2",{attrs:{id:"react18-更新了哪些内容"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react18-更新了哪些内容"}},[t._v("#")]),t._v(" React18 更新了哪些内容？")]),t._v(" "),n("p",[t._v("React18 带来了一个新的 API：ReactDOM.createRoot，这个 API 将用于替换 ReactDOM.render。它将会添加 React18 的改进并且支持 concurrent 模式。")]),t._v(" "),n("p",[t._v("旧版的 ReactDOM.render 将会以 legacy 模式继续存在，但是开发环境下会报 warning，后续开发不建议再使用。")]),t._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 从接收两个参数 -> 一个")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ReactDOM.render(jsx,document.getElementById('root'))")]),t._v("\nReactDOM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("createRoot")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("document"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'root'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("jsx"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br")])]),n("p",[t._v("跟踪依赖：\nuseEffect（异步）、useLayoutEffect（同步，立即更新）")]),t._v(" "),n("blockquote",[n("p",[t._v("Vue 是数据响应、React 是依赖收集")])]),t._v(" "),n("p",[t._v("面试时："),n("strong",[t._v("能掌握的就说出来，不能掌握的就背下来")])]),t._v(" "),n("blockquote",[n("p",[t._v("onClick 使用驼峰命名 是因为 react 中的合成事件帮我们把事件addEventListener 监听了 然后挂载到 dom 节点上")])]),t._v(" "),n("blockquote",[n("p",[t._v("useState就是 useReduer的语法糖 state管理一个状态 如果有多个状态 使用reduer 就不用写多个state了")])]),t._v(" "),n("h2",{attrs:{id:"待整理面试题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#待整理面试题"}},[t._v("#")]),t._v(" 待整理面试题")]),t._v(" "),n("p",[t._v("setTimeout为什么最小只能设置4ms，怎么实现一个0ms的setTimeout?\n看你简历上有写到rem和vw，能讲讲吗？为什么你选择使用rem而不是vw？\n当时回答是rem兼容性更好，且px转rem后可以避免过长小数。\n浏览器对于小数单位是怎么计算的？\n当时没答上来，只说了句四舍五入，后续查阅相关资料得知不同浏览器策略不同，有的会四舍五入，有的会直接取整。不管什么单位，浏览器最后都会Computed为px后再进行渲染。\ninterface和type的区别是什么？你日常工作中是用interface还是type？\nts的逆变和协变有没有了解过？\n没有\n能不能讲讲小程序的原理？\n网上很多相关文章，把双线程讲出来就行。\n看你之前有做过Taro，能不能讲讲React是怎么跑在小程序里面的？\n大概把Taro3的原理讲了一遍，主要是jsx->vdom->json->wxml，具体可以看这里 Taro预渲染[10] 和 Remax实现原理[11] ，之前写过demo，所以对这块还是比较了解。\n你刚才讲到json->wxml这一步可以有两种方式(template递归和自定义组件递归)，能不能讲讲两种方式的优劣？\n简单讲了一下，template递归是纯视图层的操作，性能肯定更好，但是由于微信小程序wxml编译器的限制，template不能递归调用自己(支付宝小程序无此限制)，所以Taro在微信环境中把同一个template写了n份，只有id不同，就是为了递归渲染。\n而自定义组件递归还要涉及到逻辑层，例如生命周期等，性能会差一些，同时还有Shadow DOM引起的样式问题，目前kbone使用的是自定义组件递归。\n小程序有没有HMR，能不能讲讲HMR的原理？\n小程序没有HMR，当时只讲出来了保存代码小程序是怎么刷新的，HMR没有讲出来。\n讲讲z-index\n讲讲position\n实现一个ts Include\n不会\n实现一个useInterval\n写的不是太对\njs event loop执行顺序\n实现一个immutable\nfunction immutable(obj) {\nreturn {\nset(path, val) {\nconst paths = path.split('.')\nconst lastK = paths.pop()\nthis.get(paths.join('.'))[lastK] = val\nreturn this\n},\nget(path) {\nconst paths = path.split('.')\nreturn paths.reduce((a, k) => a[k], obj)\n}\n}\n}")]),t._v(" "),n("p",[t._v("options请求是什么？有什么作用？\ncdn的原理是什么，是在网络哪一层起的作用？\n项目性能是如何做优化的？\n我主要从网络，缓存，js，css，接口合并等几个方面讲的，该题比较宽泛，可自行发挥。\n动态创建script标签并插入到页面上，说执行时机\n给你一个“A2B3”这样的字符串，输出“AABBB”\n接上题“C4(A(A3B)2)2”，带嵌套的，这两题都不是原题，但是类似\n写一个curry，要求 add(1)(2)(3)(4) 打印10\n一开始我洗的add(1)(2)(3)(4)()，面试官问我能不能把最后的()去掉，最后寻求提示，他说console.log是怎么打印函数的，豁然开朗，复写toString即可。")]),t._v(" "),n("p",[t._v("loader和plugin的区别是什么？\nwebpack打包优化，我还提到了vite，顺便讲了下vite\n小程序原理，以及Taro原理\nxss和csrf\nhttp2\nTree Shaking原理\n最长回文子串\n大数相加")]),t._v(" "),n("p",[t._v("聊了很多工程化相关的问题，主要是项目从开发到上线这一整套流程，聊完之后他也指出了我说的这一套流程有什么不完善的地方。\nReact fiber\nhttp2\nTree Shaking原理\n项目优化和网络优化\n股票最大收益\n大数相加")]),t._v(" "),n("p",[t._v("useEffect中return函数的作用和执行时机")]),t._v(" "),n("p",[t._v("setState是同步还是异步的")]),t._v(" "),n("p",[t._v("fiber的实现原理")]),t._v(" "),n("p",[t._v("fiber的时间调度通过哪两个原生api实现的（requestAnimationFrame和requestIdleCallback？？？）")]),t._v(" "),n("p",[t._v("react合成事件是如何实现的")]),t._v(" "),n("p",[t._v("使用redux时需要注意的点")]),t._v(" "),n("p",[t._v("如果redux没返回新的数据会怎样")]),t._v(" "),n("p",[t._v("redux是如何派发数据的？ connect原理？")]),t._v(" "),n("p",[t._v("什么场景会触发重新渲染")]),t._v(" "),n("p",[t._v("setState返回一样的引用，render会执行吗")]),t._v(" "),n("p",[t._v("useEffect的使用方法？useEffect的return会在什么时候执行？useEffect原理是什么？")]),t._v(" "),n("p",[t._v("useMemo和useCallback的区别，它们的实现原理是什么？")]),t._v(" "),n("p",[t._v("useEffect、useMemo、useCallback是如何做依赖收集的")]),t._v(" "),n("p",[t._v("React Hooks有什么优势和劣势")]),t._v(" "),n("p",[t._v("context的实现原理是什么？如何做依赖收集？")]),t._v(" "),n("p",[t._v("React的生命周期")]),t._v(" "),n("p",[t._v("PureComponent和Component的区别")]),t._v(" "),n("p",[t._v("如果在map循环中没有设置key值，那么从 A B C D 四个节点变成 B C D三个节点，它会以什么样的方式变化")]),t._v(" "),n("p",[t._v("React dom绑定事件和原生事件有什么区别")]),t._v(" "),n("p",[t._v("Hooks的实现原理")])])}),[],!1,null,null,null);e.default=s.exports}}]);