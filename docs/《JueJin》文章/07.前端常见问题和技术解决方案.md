---
title: 前端常见问题和技术解决方案
date: 2022-05-17 17:54:25
permalink: /pages/c7af68/
categories:
  - 《JueJin》文章
tags:
  - 
---


# 前端常见问题和技术解决方案

**Example**

- 跨域
- 轮播图
- 图片、路由懒加载
- 大文件断点续传
- 文件下载
- 单点登录 sso 实现
- 前端水印
- 扫描二维码登录原理
- 滚动加载
- 渲染大数据

## 跨域

**产生原因**

> 同源策略，浏览器同源策略限制请求，同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

**产生影响**

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 JS 对象无法获得
- AJAX 请求发送会被浏览器拦截

**特例：有三个标签是允许跨域加载资源**

- `<img src=XXX  />`
- `<link href=XXX>`
- `<script src=XXX><script>`

**解决方案**

- 通过 jsonp 跨域
  - 动态的创建 script 标签，然后 src 设置为请求地址并指定回调函数
- document.domain + iframe 跨域
  - 仅限主域相同，子域不同的跨域应用场景
- location.hash + iframe
  - a 与 b 跨域相互通信，通过中间页 c 来实现。三个页面，不同域之间利用iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。
- window.name + iframe 跨域
- postMessage 跨域
  - postMessage 一般用于解决以下问题
    - 页面和其打开的新窗口的数据传递
    - 多窗口之间消息传递
    - 页面与嵌套的 iframe 消息传递
- **跨域资源共享（CORS）：主流的跨域解决方案**
  - 服务端设置 Access-Control-Allow-Origin 即可
  - 若要带 cookie 请求：前后端都需要设置
- nginx 代理跨域
- nodejs 中间件代理跨域
- WebSocket 协议跨域

> 在 CORS 中，默认的，只允许客户端读取下面六个响应头（在axios响应对象的headers里能看到）：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma

如果这六个以外的响应头要是想让客户端读取到，就需要设置 Access-Control-Expose-Headers 这个为响应头名了，比如 Access-Control-Expose-Headers: Token
Access-Control-Max-Age：设置预检请求的有效时长，就是服务器允许的请求方法和请求头做个缓存

> node 中间件实现跨域代理，原理大致与 nginx 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 cookieDomainRewrite参 数修改响应头中 cookie 中域名，实现当前域的 cookie 写入，方便接口登录认证。

> WebSocket protocol是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。原生  WebSocket API 使用起来不太方便，我们使用 Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。

```js
// 1. 通过 jsonp 跨域
// script标签不受策略影响，可以动态生成script去请求数据，但是仅限Get请求
<script>
  var script = document.createElement('script');
  script.type = 'text/javascript';   
  // 传参并指定回调执行函数为onBack
  script.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack';    
  document.head.appendChild(script);    
  // 回调执行函数
  function onBack(res) {
    alert(JSON.stringify(res));
  } 
</script>

// Vue 实现
this.$http.jsonp(
  'http://www.domain2.com:8080/login', 
   {    
     params: {},    
    jsonp: 'onBack'
   }
  ).then(res => { console.log(res); }
) 

// 2. document.domain + iframe 跨域
// 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域
<!-- 父窗口：http://www.domain.com/a.html -->
<iframe id="iframe" src="http://child.domain.com/b.html">
</iframe>

<script>
  document.domain = 'domain.com';    
  var user = 'admin';
</script>

<!-- 子窗口：http://child.domain.com/b.html -->
<script>
  document.domain = 'domain.com';    
  // 获取父窗口中变量
  alert('get js data from parent ---> '+ window.parent.user);
</script>

// 3. location.hash + iframe
// 具体实现： A域：a.html -> B域：b.html -> A域：c.html，

// a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

// 4. window.name + iframe 跨域
// window.name 属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。
// 通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。

// 5. postMessage 跨域
<!-- a页面：http://www.domain1.com/a.html -->
<iframe id="iframe" 
        src="http://www.domain2.com/b.html" 
        style="display:none;">
</iframe>
<script>       
  var iframe = document.getElementById('iframe');
  iframe.onload = function() {        
    var data = {           
      name: 'aym'
    };        
    // 向domain2传送跨域数据
    iframe.contentWindow.postMessage
    (JSON.stringify(data),
     'http://www.domain2.com');
  };    
  // 接受domain2返回数据
  window.addEventListener
  ('message', function(e) {
    alert('data from domain2 ---> ' + e.data);
  }, 
   false);
</script>

<!-- b页面：http://www.domain2.com/b.html -->
<script>
  // 接收domain1的数据
  window.addEventListener
  ('message', function(e) {
    alert('data from domain1 ---> ' + e.data);        
    var data = JSON.parse(e.data);        
    if (data) {
      data.number = 16;            
      // 处理后再发回domain1
      window.parent.postMessage(JSON.stringify(data),
                                'http://www.domain1.com');
    }
  }, false);
</script>

// webSocket 跨域
<div>user input：
  <input type="text">
</div>

<script src="./socket.io.js"></script>
<script>var socket = io('
                        http://www.domain2.com:8080');
                        // 连接成功处理
                        socket.on('connect', function() {    
    // 监听服务端消息
    socket.on('message', function(msg) {        
      console.log('data from server: ---> ' + msg); 
    });   
    // 监听服务端关闭
    socket.on('disconnect', function() { 
      console.log('Server socket has closed.'); 
    });
  });
  document.getElementsByTagName('input')
  [0].onblur = function() {
    socket.send(this.value);
  };
 </script>
```

## 轮播图

### 借助组件或者框架

- Swiper、BootStrap

### css3 动画实现的轮播图

实现原理：

- 设置大的div   
  - 设置绝对定位，定位位置，
  - 设置图片展示出来的高度和宽度（height和width）；
  - 设置overflow:hidden;设置超出部分隐藏；使得图片只能在这个框中显示；
- 设置小的div,将所有图片都包起来；宽度是所有图片的宽度；设置position:relative / position:absolute  来让它可以实现轮播的功能；必不可少。（自己的理解，设置大div和小div 的position,来让div浮起来，脱离文档流，就像云一样，可以飘了~）
- 给里面的图片设置float:left;向左浮动，可以让所有图片都在同一行；如果没有float:left；会导致图片轮播的时候出现空白；
- 加入动画；每次都向左偏移一个图片的宽度，即可实现图片轮播；
- 将第一张图片与最后一张图片设置成一样的，是为了实现视觉上的无缝连接

### JS 方法

轮播图原理就是图片的移动。所有轮播图片横向排列，在一个窗口中显示一张图片，窗口外的图片隐藏，每一次一排图片就是移动一张图片的距离，切换到下一张图片，即可实现图片轮播。

图片的移动有两种方式：

- translate 实现的图片移动
- position定位实现图片的偏移

图片的自动播放，使用间隔定时器 setInterval

通过定位的方式，改变left或top的值，形成轮播图的效果

**1、自动轮播：**

用setInterval(func，time)；
被调用的函数不断地自加，也就是不断地往后循环，当图片到最后一张时，让其跳转到第一张。
先将所有图片，下方指示点的样式设置为一样的，再对当前索引对应的图片，设置特别的样式。

**2、鼠标移入，移出事件**

注意：
1）如果你想要通过点击事件来改变图片的移动时，就必须让鼠标移动到上面时设置清除计时器；因为如果不设置的话，当你通过点击事件改变它时，它自身也会自己改变，会出现混乱。
2）当清除完后，鼠标移出后需要重新启动计时器，这时候不能再给它设置var jishi;因为如果再加上var 的话，相当于重新又定义了一个变量，会有好几个计时器同时进行，会越来越快。

**3、手动轮播，底下指示点的按钮控制**

判断点击的是哪个点，然后将它的索引值赋值给index，再通过调用change功能，实现它的改变。

**4、左右按钮的控制**
让它实现自增或自减，然后调用change功能来改变样式。 其实这里的知识点和自动轮播里的知识点差不多。（从最后一张图片跳转到第一张图片 ，从第一张跳转到最后一张。）
无论是自动轮播，还是点击控制，都要加入change功能以及index 来实现对样式的控制，从而实现轮播的效果。

## 图片加载

**原理**

优先加载可视区域的内容，其他部分等进入了可视区域再加载，从而提高性能

**原理**

一张图片就是一个 img 标签，浏览器是否发起请求是根据 img 的 src 属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给 img 的 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给 src 赋值

**实现思路**

- 加载 loading 图片
- 判断哪些图片要加载
  - 当图片距离顶部 top-height 等于可视区域 h 和滚动区域高度 s 之和时说明图片马上要进入可视区域了
- 隐形加载图片
  - 创建一个临时图片，new Image()，不会加载到页面上，实现隐形加载
- 替换真图片
  - 替换 src 属性

**页面布局位置基础知识**

> - 网页可见区域宽： document.body.clientWidth;
> - 网页可见区域高： document.body.clientHeight;
> - 网页可见区域宽： document.body.offsetWidth (包括边线的宽);
> - 网页可见区域高： document.body.offsetHeight (包括边线的高);

> - 网页正文全文宽： document.body.scrollWidth;
> - 网页正文全文高： document.body.scrollHeight;
> - 网页被卷去的高： document.body.scrollTop;
> - 网页被卷去的左： document.body.scrollLeft;

> - 网页正文部分上： window.screenTop;
> - 网页正文部分左： window.screenLeft;
> - 屏幕分辨率的高： window.screen.height;
> - 屏幕分辨率的宽： window.screen.width;
> - 屏幕可用工作区高度： window.screen.availHeight;

- 对块级元素来说，offsetTop、offsetLeft、offsetWidth 及 offsetHeight 描述了元素相对于 offsetParent 的边界框
- HTMLElement.offsetParent 是一个只读属性，返回一个指向最近的（指包含层级上的最近）包含该元素的定位元素或者最近的 table,td,th,body元素。当元素的 style.display 设置为 "none" 时，offsetParent 返回 null。offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的。
- HTMLElement.offsetTop 为只读属性，它返回当前元素相对于其 offsetParent 元素的顶部的距离。
- window.innerHeight：浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。

**代码实现**

可以给 img 标签统一自定义属性 data-src='default.png'，当检测到图片出现在窗口之后再补充 src 属性，此时才会进行图片资源加载。

```js
function lazyload() {
  const imgs = document.getElementsByTagName('img');
  const len = imgs.length;
  // 视口的高度
  const viewHeight = document.documentElement.clientHeight;
  // 滚动条高度
  const scrollHeight = document.documentElement.scrollTop || document.body.scrollTop;
  for (let i = 0; i < len; i++) {
    const offsetHeight = imgs[i].offsetTop;
    if (offsetHeight < viewHeight + scrollHeight) {
      const src = imgs[i].dataset.src;
      imgs[i].src = src;
    }
  }
}

// 可以使用节流优化一下
window.addEventListener('scroll', lazyload);
```

## 前端水印

- 显性水印 + DOM 元素直接遮盖：将水印文字直接通过一层DOM元素，覆盖到需要添加水印的图片上
- 显性水印 + Canvas：
算法和显性水印 + DOM 元素直接遮盖一样，但其性能优于方案一，安全性略高于方案一直接通过 Canvas 绘画，避免了在水印密度较大的情况下大量 DOM 元素的创建与添加并且 Canvas 在部分环境与浏览器下拥用 GPU 加速的功能，故而性能提升较大
- 保护程序+DOM元素直接遮盖
上述方案中，将资源绘制在 Canvas 虽是一种可行方案，但对于普通的 DOM 元素（非图片）虽然有可行方案例如 html2 canva 来将 DOM 转化为·Canvas，但是实现过于繁杂并且 DOM 将失去其事件处理响应功能，故而并不推荐这么使用，除非需要保护的资源没有任何交互使用浏览器新增的 MutationObserver 特性（主流浏览器都已支持，参考资料中有具体文档链接）用来监视需要保护的 DOM 元素及其子代的更改（包括监视 DOM 及其子代的删减、Style 的变化，标签属性变化等等），一旦回调函数通知出现了任何更改。我们可以做出提示，提醒用户操作违法，并且删除掉水印，并且重新生成水印 DOM 或者在用户更改了水印 DOM 的时候，将需要显示的保护资源 DOM 一并删除
- Base64 传输
将资源文件通过Base64编码并且通过request请求返回（或是直接后端保存Base64）
而对于Img来说，Base64只需要一些小小的的处理就可以在Web中使用（Base64字符串可以直接作为img的url，但建议使用Js Image对象，这样避免了暴露原始URL到HTML中
- 加料的 Base64

## Ending

[原文章链接](https://juejin.cn/post/7088144745788080142)