---
title: CSS
date: 2021-08-10 14:51:42
permalink: /pages/9afa99/
categories:
  - 面试
  - BASE
tags:
  - 
---

# CSS

古人云：水满则溢，月满则亏，自满则败，自矜则愚。反思做人与做事的道理，二八定律都蕴含着大智慧。人生的道路，就是不断摸索，进而失败，再摸索，才去的成功。量变才有质的飞跃，没有量变的质，是空洞的，是一碰就碎的。

查考的 CSS 知识：

- BFC
- 盒模型
- 选择器的权重
- 兼容性的一些问题
- 定位布局（最基础）
  - 绝对定位
  - Flex
  - Grid
  - Table
  - 等等
- Flex 弹性布局（拉出来讲）
- 媒体查询
  - 响应式布局
  - px、em、rem

<!-- more -->

## BFC

BFC（Block Formatting Context）块级格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。

- BFC 形成条件：
  - 1、浮动元素，float 除 none 以外的值；
  - 2、定位元素，position（absolute，fixed）；
  - 3、display 为以下其中之一的值 inline-block，table-cell，table-caption；
  - 4、overflow 除了 visible 以外的值（hidden，auto，scroll）；
- BFC 特性：
  - 1、内部的 Box 会在垂直方向上一个接一个的放置；
  - 2、垂直方向上的距离由margin 决定；（解决外边距重叠问题）
  - 3、bfc 的区域不会与 float 的元素区域重叠；（防止浮动文字环绕）
  - 4、计算 bfc 的高度时，浮动元素也参与计算；（清除浮动）
  - 5、bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素；

**BFC（Block Formatting Context）格式化上下文**，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。
BFC 即 Block Formatting Contexts (块级格式化上下文)，属于普通流。
可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。

### 怎样触发BFC

> BFC = OFDP; overflow，float，display， position;

- overflow: hidden
- display: inline-block
- position: absolute
- position: fixed
- display: table-cell
- display: flex

### BFC的规则

- BFC就是一个块级元素，块级元素会在垂直方向一个接一个的排列
- BFC就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签
- 垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的标签外边距会发生重叠
- 计算BFC的高度时，浮动元素也参与计算

### BFC解决了什么问题

- 使用Float脱离文档流，高度塌陷
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width， initial-scale=1.0">
    <title>高度塌陷</title>
    <style>
        .box {
            margin: 100px;
            width: 100px;
            height: 100px;
            background: red;
            float: left;
        }
        .container {
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
    </div>
</body>
</html>

// 可以看到上面效果给box设置完float结果脱离文档流，使container高度没有被撑开，从而背景颜色没有颜色出来，解决此问题可以给container触发BFC，上面我们所说到的触发BFC属性都可以设置
// 解决办法
 .container {
            background: #000;
            display: inline-block;
    }
```

- Margin边距重叠
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width， initial-scale=1.0">
    <title>Document</title>
    <style>
        .box {
            margin: 10px;
            width: 100px;
            height: 100px;
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
    </div>
</body>
</html>

// 可以看到上面我们为两个盒子的margin外边距设置的是10px，可结果显示两个盒子之间只有10px的距离，这就导致了margin塌陷问题，这时margin边距的结果为最大值，而不是合，为了解决此问题可以使用BFC规则（为元素包裹一个盒子形成一个完全独立的空间，做到里面元素不受外面布局影响），或者简单粗暴方法一个设置margin，一个设置padding。

// 解决办法
<div class="container">
        <div class="box"></div>
        <p><div class="box"></div></p>
    </div>

```

- 两栏布局
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width， initial-scale=1.0">
    <title>两栏布局</title>
    <style>
            div {
                 width: 200px;
                 height: 100px;
                 border: 1px solid red;
            }

    </style>
</head>
<body>
    <div style="float: left;">
        两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局
    </div>
    <div style="width: 300px;">
        我是蛙人，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭
    </div>
</body>
</html>

// 可以看到上面元素，第二个div元素为300px宽度，但是被第一个div元素设置Float脱离文档流给覆盖上去了，解决此方法我们可以把第二个div元素设置为一个BFC。

// 解决办法
  <div style="width: 300px;display:flex;">
        我是蛙人，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭
    </div>
```

### 形成BFC的条件

1、浮动元素，float 除 none 以外的值； 
2、绝对定位元素，position（absolute，fixed）； 
3、display 为以下其中之一的值 inline-block，table-cell，table-caption、flex； 
4、overflow 除了 visible 以外的值（hidden，auto，scroll）；
5、body 根元素；

### BFC 的特性

1.内部的Box会在垂直方向上一个接一个的放置。
2.垂直方向上的距离由margin决定。（外边距折叠）
  两个兄弟盒子之间的垂直距离是由他们的外边距所决定的，但不是他们的两个外边距之和，而是以较大的为准
3.bfc的区域不会与float的元素区域重叠。
4.计算bfc的高度时，浮动元素也参与计算
5.bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。

### BFC 与 IFC 区别

BFC 是块级格式上下文，IFC 是行内格式上下文：
- 内部的 Box 会水平放置
- 水平的间距由 margin，padding，border 决定

#### 问题1：在不浮动的情况下，当一个子盒子在一个父盒子当中，给子盒子设置margin-top，浏览器会错放在父盒子身上

```html
<style>
        *{
            margin: 0;
            padding: 0;
        }
        .father{
            width: 200px;
            height: 200px;
            background-color: red;
        }
        .son{
            margin-top: 10px;
            width: 100px;
            height: 100px;
            background-color: orange;
        }
    </style>
</head>
<body>
   <div class="father">
       <div class="son"></div>
   </div>
</body>
```

如何想只给子盒子设置，而不会错设置在父盒子上

**解决办法：**

- 父元素盒子前加上一个伪类::before{content="";display="table"}

#### 问题2：当两个相邻的元素在一起设置上下margin值的时候会出现什么情况？

> 只会取margin值最大的那一个生效

```html
 <style>
        *{
            margin: 0;
            padding: 0;
        }
        .shang{
            width: 100px;
            height: 100px;
            background-color: red;
            margin-bottom: 10px;
            overflow: hidden;
        }
        .xia{
            width: 100px;
            height: 100px;
            background-color: orange;
            margin-top: 20px;
            overflow: hidden;
        }
  </style>
</head>
<body>
   <div class="shang"></div>
   <div class="xia"></div>
</body>
```

**解决办法**
> 给下面盒子设置{display: inline-block;} 或者{position: absolute;}

是由块级格式上下文决定的，BFC，元素在 BFC 中会进行上下排列，然后垂直距离由 margin 决定，并且会发生重叠，具体表现为同正取最大的，同负取绝对值最大的，一正一负，相加；BFC 是页面中一个独立的隔离容器，内部的子元素不会影响到外部的元素。



## CSS 盒模型

- 标准模型
  - box-sizing:border-box;
  - 宽度=内容的宽度（content）+ border + padding
- ie 模型
  - box-sizing:content-box;
  - 宽度=内容宽度（content+border+padding）

## CSS 优先级是怎么计算的

第一优先级：!important 会覆盖页面内任何位置的元素样式

- 内联样式，如 style="color: green"，权值为 1000
- ID 选择器，如#app，权值为 0100
- 类、伪类、属性选择器，如.foo，:first-child，div[class="foo"]，权值为 0010
- 标签、伪元素选择器，如 div::first-line，权值为 0001
- 通配符、子类选择器、兄弟选择器，如*， >， +，权值为 0000
- 继承的样式没有权值

## 两个div上下排列，都设margin，有什么现象？

- 都正取大
- 一正一负相加

## 常见定位方案

- **普通流**
  默认，从上而下，行内元素水平排列，行满换行，块级元素渲染成一个新行。
- **浮动**
  先按普通流位置出现，然后根据浮动方向偏移。
- **绝对定位**
  元素具体位置由绝对定位坐标组成。

### position（绝对布局）

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```
```css
body,html,.container{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
/*左右进行绝对定位*/
.left,.right{
    position: absolute;
    height:100%;
    top: 0;
    background: #333;
}
.left{
    left: 0;
    width: 200px;
}
.right{
    right: 0;
    width: 200px;
}
/*中间用margin空出左右元素所占的空间*/
.main{
    height:100%;
    margin: 0 200px;
    background: red;
}
/*或者中间也进行绝对定位*/
.main{
    position: absolute;
    height:100%;
    left: 200px;
    right:200px;
    background: red;
}
```

> 优点：简单粗暴；
> 缺点: 脱离文档流 高度未知会出现问题 可用性差

### flex（弹性盒子布局）

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

```css
body,html{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container{
    display: flex;
}
.left{
    width:200px;
    background: red;
}
.main{
    flex: 1;
    background: blue;
}
.right{
    width:200px;
    background: red;
}
```

> 优点：比较完美 移动端首选；缺点: 不兼容 ie9 及以下

### table(表格布局)

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

```css
body，html{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container{
    display: table;
    width:100%;
}
.container>div{
    display: table-cell;
}
.left{
    width: 200px;
    background: red;
}
.main{
    background: blue;
}
.right{
    width: 200px;
    background: red;
}
```

> 优点：兼容性很好（ie8 及以上） 父元素高度会被子元素撑开（不担心高度塌陷）:缺点: seo 不友好 当其中一个单元格高度超出的时候，其他的单元格也是会跟着一起变高的

### Grid(网格布局)

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

```css
body，html{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container{
    display: grid;
    width: 100%;
    grid-template-rows: 100px;  /*设置行高*/
    grid-template-columns: 200px auto 200px;  /*设置列数属性*/
}
.left{
    background: red;
}
.main{
    background: blue;
}
.right{
    background:red;
}
```

> 优点：简单强大 解决二维布局问题；缺点: 不兼容 ie9 及以下

- float
- position:absolute
- flex
- table
- grid










## CSS 实现水平/垂直居中

**CSS2 水平居中**
- div + margin: 0 auto;
- span + text-align

**CSS2 垂直居中**
- 使用 position 然后 left/top 和 margin 的方式垂直居中（已知宽高和未知宽高）
- 使用 position + margin
- 使用 display: table-cell;

**CSS3**

```javascript
// 父元素设置
display: flex;       
/* 垂直居中 */
align-items: center;
/* 水平居中 */
justify-content: center;
```

## 三栏布局问题（左右固定宽度 中间自适应）

### 1.float + margin（浮动布局）
```html
<div class="container">
    <div class="left">Left</div>
     <!-- 右栏部分要写在中间内容之前 -->
    <div class="right">Right</div>
    <div class="main">Main</div>
</div>
```
```css
body,html,.containerl{
    height: 100%;
    padding:0;
    margin: 0;
}
/*左边栏左浮动*/
.left{
    float:left;
    height:100%;
    width:200px;
    background:#333;
}
/*中间栏自适应*/
.main{
    height:100%;
    margin:0 200px;
    background: red;
}
/*右边栏右浮动*/
.right{
    float:right;
    height:100%;
    width:200px;
    background:#333;
}
```

> 优点：快捷 简单 兼容性较好；
> 缺点: 有局限性 脱离文档流 需要清除浮动等## div+css 的布局较 table 布局有什么优点

- 改版的时候更方便 只要改 css 文件。
- 页面加载速度更快、结构化清晰、页面显示简洁。
- 表现与结构相分离。
- 易于优化（ seo ）搜索引擎更友好，排名更容易靠前。

## 清除浮动有哪些方法？

不清楚浮动会发生高度塌陷：浮动元素父元素高度自适应（**父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷**）

- clear清除浮动（添加空div法）在浮动元素下方添加空div，并给该元素写css样式：{clear:both;height:0;overflow:hidden;}
- 给浮动元素父级设置高度
- 父级同时浮动（需要给父级同级元素添加浮动）
- 父级设置成 inline-block ，其 margin: 0 auto 居中方式失效
- 给父级添加 overflow:hidden 清除浮动方法
- 万能清除法 after 伪类 清浮动（现在主流方法，推荐使用）

```javascript
// 万能清除浮动法
父元素:after{
    content: "";
    height: 0;
    clear: both;
    overflow: hidden;
    display: block;
    visibility: hidden;
}
```

## css 怎么开启硬件加速(GPU 加速)

- 采用 transform: translateZ(0)
- 采用 transform: translate3d(0, 0, 0)
- 使用 CSS 的 will-change属性。 will-change 可以设置为opacity、transform、top、left、bottom、right。

## flex:1 是哪些属性组成的

flex 实际上是 flex-grow、flex-shrink 和 flex-basis 三个属性的缩写。

- flex-grow：定义项目的的放大比例；
- flex-shrink：定义项目的缩小比例；
- flex-basis：定义在分配多余空间之前，项目占据的主轴空间（main size），浏览器根据此属性计算主轴是否有多余空间；

## px、em、rem 区别

- px 是固定的像素，一旦设置了就无法因为适应页面大小而改变。
- em 和 rem 相对于 px 更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。
- em 相对于父元素，rem 相对于根元素