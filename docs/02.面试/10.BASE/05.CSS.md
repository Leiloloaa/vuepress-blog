---
title: CSS
date: 2021-08-10 14:51:42
permalink: /pages/9afa99/
categories:
  - 面试
  - BASE
tags:
  - 
---

# CSS

古人云：水满则溢，月满则亏，自满则败，自矜则愚。反思做人与做事的道理，二八定律都蕴含着大智慧。人生的道路，就是不断摸索，进而失败，再摸索，才去的成功。量变才有质的飞跃，没有量变的质，是空洞的，是一碰就碎的。

查考的 CSS 知识：

- BFC
- 盒模型
- 选择器的权重
- 兼容性的一些问题
- 定位布局（最基础）
  - 绝对定位
  - Flex
  - Grid
  - Table
  - 等等
- Flex 弹性布局（拉出来讲）
- 媒体查询
  - 响应式布局
  - px、em、rem
- 边框

<!-- more -->

## BFC

BFC（Block Formatting Context）块级格式化上下文，是 Web 页面中盒模型布局的 CSS 渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。

- BFC 形成条件：
  - 1、浮动元素，float 除 none 以外的值；
  - 2、定位元素，position（absolute，fixed）；
  - 3、display 为以下其中之一的值 inline-block，table-cell，table-caption；
  - 4、overflow 除了 visible 以外的值（hidden，auto，scroll）；
- BFC 特性：
  - 1、内部的 Box 会在垂直方向上一个接一个的放置；
  - 2、垂直方向上的距离由margin 决定；（解决外边距重叠问题）
  - 3、bfc 的区域不会与 float 的元素区域重叠；（防止浮动文字环绕）
  - 4、计算 bfc 的高度时，浮动元素也参与计算；（清除浮动）
  - 5、bfc 就是页面上的一个独立容器，容器里面的子元素不会影响外面元素；

**BFC（Block Formatting Context）格式化上下文**，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。
BFC 即 Block Formatting Contexts (块级格式化上下文)，属于普通流。
可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。BFC是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。

### 怎样触发BFC

> BFC = OFDP; overflow，float，display， position;

- overflow: hidden
- display: inline-block
- position: absolute
- position: fixed
- display: table-cell
- display: flex

### BFC的规则

- BFC就是一个块级元素，块级元素会在垂直方向一个接一个的排列
- BFC就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签
- 垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的标签外边距会发生重叠
- 计算BFC的高度时，浮动元素也参与计算

### BFC解决了什么问题

- 使用Float脱离文档流，高度塌陷
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width， initial-scale=1.0">
    <title>高度塌陷</title>
    <style>
        .box {
            margin: 100px;
            width: 100px;
            height: 100px;
            background: red;
            float: left;
        }
        .container {
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
    </div>
</body>
</html>

// 可以看到上面效果给box设置完float结果脱离文档流，使container高度没有被撑开，从而背景颜色没有颜色出来，解决此问题可以给container触发BFC，上面我们所说到的触发BFC属性都可以设置
// 解决办法
 .container {
            background: #000;
            display: inline-block;
    }
```

- Margin边距重叠
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width， initial-scale=1.0">
    <title>Document</title>
    <style>
        .box {
            margin: 10px;
            width: 100px;
            height: 100px;
            background: #000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
    </div>
</body>
</html>

// 可以看到上面我们为两个盒子的margin外边距设置的是10px，可结果显示两个盒子之间只有10px的距离，这就导致了margin塌陷问题，这时margin边距的结果为最大值，而不是合，为了解决此问题可以使用BFC规则（为元素包裹一个盒子形成一个完全独立的空间，做到里面元素不受外面布局影响），或者简单粗暴方法一个设置margin，一个设置padding。

// 解决办法
<div class="container">
        <div class="box"></div>
        <p><div class="box"></div></p>
    </div>

```

- 两栏布局
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width， initial-scale=1.0">
    <title>两栏布局</title>
    <style>
            div {
                 width: 200px;
                 height: 100px;
                 border: 1px solid red;
            }

    </style>
</head>
<body>
    <div style="float: left;">
        两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局
    </div>
    <div style="width: 300px;">
        我是蛙人，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭
    </div>
</body>
</html>

// 可以看到上面元素，第二个div元素为300px宽度，但是被第一个div元素设置Float脱离文档流给覆盖上去了，解决此方法我们可以把第二个div元素设置为一个BFC。

// 解决办法
  <div style="width: 300px;display:flex;">
        我是蛙人，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭
    </div>
```

### 形成BFC的条件

1、浮动元素，float 除 none 以外的值； 
2、绝对定位元素，position（absolute，fixed）； 
3、display 为以下其中之一的值 inline-block，table-cell，table-caption、flex； 
4、overflow 除了 visible 以外的值（hidden，auto，scroll）；
5、body 根元素；

### BFC 的特性

1.内部的Box会在垂直方向上一个接一个的放置。
2.垂直方向上的距离由margin决定。（外边距折叠）
  两个兄弟盒子之间的垂直距离是由他们的外边距所决定的，但不是他们的两个外边距之和，而是以较大的为准
3.bfc的区域不会与float的元素区域重叠。
4.计算bfc的高度时，浮动元素也参与计算
5.bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素。

### BFC 与 IFC 区别

BFC 是块级格式上下文，IFC 是行内格式上下文：
- 内部的 Box 会水平放置
- 水平的间距由 margin，padding，border 决定

#### 问题1：在不浮动的情况下，当一个子盒子在一个父盒子当中，给子盒子设置margin-top，浏览器会错放在父盒子身上

```html
<style>
        *{
            margin: 0;
            padding: 0;
        }
        .father{
            width: 200px;
            height: 200px;
            background-color: red;
        }
        .son{
            margin-top: 10px;
            width: 100px;
            height: 100px;
            background-color: orange;
        }
    </style>
</head>
<body>
   <div class="father">
       <div class="son"></div>
   </div>
</body>
```

如何想只给子盒子设置，而不会错设置在父盒子上

**解决办法：**

- 父元素盒子前加上一个伪类::before{content="";display="table"}

#### 问题2：当两个相邻的元素在一起设置上下margin值的时候会出现什么情况？

> 只会取margin值最大的那一个生效

```html
 <style>
        *{
            margin: 0;
            padding: 0;
        }
        .shang{
            width: 100px;
            height: 100px;
            background-color: red;
            margin-bottom: 10px;
            overflow: hidden;
        }
        .xia{
            width: 100px;
            height: 100px;
            background-color: orange;
            margin-top: 20px;
            overflow: hidden;
        }
  </style>
</head>
<body>
   <div class="shang"></div>
   <div class="xia"></div>
</body>
```

**解决办法**
> 给下面盒子设置{display: inline-block;} 或者{position: absolute;}

是由块级格式上下文决定的，BFC，元素在 BFC 中会进行上下排列，然后垂直距离由 margin 决定，并且会发生重叠，具体表现为同正取最大的，同负取绝对值最大的，一正一负，相加；BFC 是页面中一个独立的隔离容器，内部的子元素不会影响到外部的元素。

## CSS 盒模型

- 标准模型
  - box-sizing:border-box;
  - 宽度=内容的宽度（content）+ border + padding
- ie 模型
  - box-sizing:content-box;
  - 宽度=内容宽度（content+border+padding）

## CSS 优先级是怎么计算的

第一优先级：!important 会覆盖页面内任何位置的元素样式

- 内联样式，如 style="color: green"，权值为 1000
- ID 选择器，如#app，权值为 0100
- 类、伪类、属性选择器，如.foo，:first-child，div[class="foo"]，权值为 0010
- 标签、伪元素选择器，如 div::first-line，权值为 0001
- 通配符、子类选择器、兄弟选择器，如*， >， +，权值为 0000
- 继承的样式没有权值

## 两个div上下排列，都设margin，有什么现象？

- 都正取大
- 一正一负相加

## 常见定位方案

- **普通流**
  默认，从上而下，行内元素水平排列，行满换行，块级元素渲染成一个新行。
- **浮动**
  先按普通流位置出现，然后根据浮动方向偏移。
- **绝对定位**
  元素具体位置由绝对定位坐标组成。

### position（绝对布局）

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```
```css
body,html,.container{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
/*左右进行绝对定位*/
.left,.right{
    position: absolute;
    height:100%;
    top: 0;
    background: #333;
}
.left{
    left: 0;
    width: 200px;
}
.right{
    right: 0;
    width: 200px;
}
/*中间用margin空出左右元素所占的空间*/
.main{
    height:100%;
    margin: 0 200px;
    background: red;
}
/*或者中间也进行绝对定位*/
.main{
    position: absolute;
    height:100%;
    left: 200px;
    right:200px;
    background: red;
}
```

> 优点：简单粗暴；
> 缺点: 脱离文档流 高度未知会出现问题 可用性差

### flex（弹性盒子布局）

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

```css
body,html{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container{
    display: flex;
}
.left{
    width:200px;
    background: red;
}
.main{
    flex: 1;
    background: blue;
}
.right{
    width:200px;
    background: red;
}
```

> 优点：比较完美 移动端首选；缺点: 不兼容 ie9 及以下

### table(表格布局)

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

```css
body，html{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container{
    display: table;
    width:100%;
}
.container>div{
    display: table-cell;
}
.left{
    width: 200px;
    background: red;
}
.main{
    background: blue;
}
.right{
    width: 200px;
    background: red;
}
```

> 优点：兼容性很好（ie8 及以上） 父元素高度会被子元素撑开（不担心高度塌陷）:缺点: seo 不友好 当其中一个单元格高度超出的时候，其他的单元格也是会跟着一起变高的

### Grid(网格布局)

```html
<div class="container">
    <div class="left">Left</div>
    <div class="main">Main</div>
    <div class="right">Right</div>
</div>
```

```css
body，html{
    height: 100%;
    padding: 0;
    margin: 0;
    overflow: hidden;
}
.container{
    display: grid;
    width: 100%;
    grid-template-rows: 100px;  /*设置行高*/
    grid-template-columns: 200px auto 200px;  /*设置列数属性*/
}
.left{
    background: red;
}
.main{
    background: blue;
}
.right{
    background:red;
}
```

> 优点：简单强大 解决二维布局问题；缺点: 不兼容 ie9 及以下

- float
- position:absolute
- flex
- table
- grid

## CSS 实现水平/垂直居中

**CSS2 水平居中**
- div + margin: 0 auto;
- span + text-align

**CSS2 垂直居中**
- 使用 position 然后 left/top 和 margin 的方式垂直居中（已知宽高和未知宽高）
- 使用 position + margin
- 使用 display: table-cell;

**CSS3**

```javascript
// 父元素设置
display: flex;       
/* 垂直居中 */
align-items: center;
/* 水平居中 */
justify-content: center;
```

## 三栏布局问题（左右固定宽度 中间自适应）

### 1.float + margin（浮动布局）
```html
<div class="container">
    <div class="left">Left</div>
     <!-- 右栏部分要写在中间内容之前 -->
    <div class="right">Right</div>
    <div class="main">Main</div>
</div>
```
```css
body,html,.containerl{
    height: 100%;
    padding:0;
    margin: 0;
}
/*左边栏左浮动*/
.left{
    float:left;
    height:100%;
    width:200px;
    background:#333;
}
/*中间栏自适应*/
.main{
    height:100%;
    margin:0 200px;
    background: red;
}
/*右边栏右浮动*/
.right{
    float:right;
    height:100%;
    width:200px;
    background:#333;
}
```

> 优点：快捷 简单 兼容性较好；
> 缺点: 有局限性 脱离文档流 需要清除浮动等## div+css 的布局较 table 布局有什么优点

- 改版的时候更方便 只要改 css 文件。
- 页面加载速度更快、结构化清晰、页面显示简洁。
- 表现与结构相分离。
- 易于优化（ seo ）搜索引擎更友好，排名更容易靠前。

## 清除浮动有哪些方法？

不清楚浮动会发生高度塌陷：浮动元素父元素高度自适应（**父元素不写高度时，子元素写了浮动后，父元素会发生高度塌陷**）

- clear清除浮动（添加空div法）在浮动元素下方添加空div，并给该元素写css样式：{clear:both;height:0;overflow:hidden;}
- 给浮动元素父级设置高度
- 父级同时浮动（需要给父级同级元素添加浮动）
- 父级设置成 inline-block ，其 margin: 0 auto 居中方式失效
- 给父级添加 overflow:hidden 清除浮动方法
- 万能清除法 after 伪类 清浮动（现在主流方法，推荐使用）

```javascript
// 万能清除浮动法
父元素:after{
    content: "";
    height: 0;
    clear: both;
    overflow: hidden;
    display: block;
    visibility: hidden;
}
```

## css 怎么开启硬件加速(GPU 加速)

- 采用 transform: translateZ(0)
- 采用 transform: translate3d(0, 0, 0)
- 使用 CSS 的 will-change属性。 will-change 可以设置为opacity、transform、top、left、bottom、right。

## flex:1 是哪些属性组成的

flex 实际上是 flex-grow、flex-shrink 和 flex-basis 三个属性的缩写。

- flex-grow：定义项目的的放大比例；
- flex-shrink：定义项目的缩小比例；
- flex-basis：定义在分配多余空间之前，项目占据的主轴空间（main size），浏览器根据此属性计算主轴是否有多余空间；

## px、em、rem 区别

- px 是固定的像素，一旦设置了就无法因为适应页面大小而改变。
- em 和 rem 相对于 px 更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。
- em 相对于父元素，rem 相对于根元素

## 选择器

选择器 示例 表述 优先级
.class	.intro	选择所有class="intro"的元素	1
#id	#firstName	选择所有id="firstName"的元素 1
*	*	选择所有元素	2
element	p	选择所有<p>元素	1
element,element	div,p	选择所有<div>元素和<p>元素	1
element element	div p	选择<div>元素内的所有<p>元素	1
element>element	div>p	选择所有父级是 <div> 元素的 <p> 元素	2
element+element	div+p	选择所有紧接着<div>元素之后的<p>元素	2 //加号选择器 经常用做分割线
[attribute]	[target]	选择所有带有target属性元素	2
[attribute=value]	[target=-blank]	选择所有使用target="-blank"的元素	2
[attribute~=value]	[title~=flower]	选择标题属性包含单词"flower"的所有元素	2
[attribute|=language]	[lang|=en]	选择一个lang属性的起始值="EN"的所有元素	2
:link	        a:link	选择所有未访问链接	1
:visited	a:visited	选择所有访问过的链接	1
:active	        a:active	选择活动链接	1
:hover	        a:hover	选择鼠标在链接上面时	1
:focus	        input:focus	选择具有焦点的输入元素	2
:first-letter	p:first-letter	选择每一个<P>元素的第一个字母	1
:first-line	p:first-line	选择每一个<P>元素的第一行	1
:first-child	p:first-child	指定只有当<p>元素是其父级的第一个子级的样式。	2
:before	p:before	在每个<p>元素之前插入内容	2//伪对象，经常使用
:after	p:after	在每个<p>元素之后插入内容	2
:lang(language)	p:lang(it)	选择一个lang属性的起始值="it"的所有<p>元素	2
element1~element2	p~ul	选择p元素之后的每一个ul元素	3
[attribute^=value]	a[src^="https"]	选择每一个src属性的值以"https"开头的元素	3
[attribute$=value]	a[src$=".pdf"]	选择每一个src属性的值以".pdf"结尾的元素	3
[attribute*=value]	a[src*="44lan"]	选择每一个src属性的值包含子字符串"44lan"的元素	3
:first-of-type	p:first-of-type	选择每个p元素是其父级的第一个p元素	3
:last-of-type	p:last-of-type	选择每个p元素是其父级的最后一个p元素	3
:only-of-type	p:only-of-type	选择每个p元素是其父级的唯一p元素	3
:only-child	p:only-child	选择每个p元素是其父级的唯一子元素	3
:nth-child(n)	p:nth-child(2)	选择每个p元素是其父级的第二个子元素	3
:nth-last-child(n)	p:nth-last-child(2)	选择每个p元素的是其父级的第二个子元素，从最后一个子项计数	3
:nth-of-type(n)	p:nth-of-type(2)	选择每个p元素是其父级的第二个p元素	3
:nth-last-of-type(n)	p:nth-last-of-type(2)	选择每个p元素的是其父级的第二个p元素，从最后一个子项计数	3
:last-child	p:last-child	选择每个p元素是其父级的最后一个子级。	3
:root	:root	选择文档的根元素	3
:empty	p:empty	选择每个没有任何子级的p元素（包括文本节点）	3
:target	#news:target	选择当前活动的#news元素（包含该锚名称的点击的URL）	3
:enabled	input:enabled	选择每一个已启用的输入元素	3
:disabled	input:disabled	选择每一个禁用的输入元素	3
:checked	input:checked	选择每个选中的输入元素	3
:not(selector)	:not(p)	选择每个并非p元素的元素	3
::selection	::selection	匹配元素中被用户选中或处于高亮状态的部分	3
:out-of-range	:out-of-range	匹配值在指定区间之外的input元素	3
:in-range	:in-range	匹配值在指定区间之内的input元素	3
:read-write	:read-write	用于匹配可读及可写的元素	3
:read-only	:read-only	用于匹配设置 "readonly"（只读） 属性的元素	3
:optional	:optional	用于匹配可选的输入元素	3
:required	:required	用于匹配设置了 "required" 属性的元素	3
:valid	:valid	用于匹配输入值为合法的元素	3
:invalid	:invalid	用于匹配输入值为非法的元素

## 边框是新特性的一大亮点

border-image	设置所有边框图像的速记属性。	3
border-radius	一个用于设置所有四个边框- *-半径属性的速记属性	3
box-shadow	附加一个或多个下拉框的阴影	3
border-radius:25px;（指定圆的半径为多少）
box-shadow:apx bpx cpx #c0c0c0;
shadow阴影的几个属性分别是向左 向下 发散（一般设置为0）最后这个是阴影的颜色

## 媒体查询是一个耀眼的星星

Media Query(也是说一些常用的): //需要注意的是,Media Query必须要加括号,一个括号是一个query max-width(max-height): @media (max-width : 600px) {/*匹配界面宽度小于600px的设备*/} min-width(min-height): @media (min-width : 400px) {/*匹配界面宽度大于400px的设备*/} max-device-width(max-device-height): @media (max-device-width : 800px) {/*匹配设备(不是界面)宽度小于800px的设备*/} min-device-width(min-device-height): @media (min-device-width : 600px) {/*匹配设备(不是界面)宽度大于600px的设备*/}

再例如
@media screen and (max-width: 960px){
    body{
        background: #000;
    }
}
这个应该算是一个media的一个标准写法，上面这段CSS代码意思是：当页面小于960px的时候执行它下面的CSS.这个应该没有太大疑问。
应该有人会发现上面这段代码里面有个screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写：

@media (max-width: 960px){
    body{
        background: #000;
    }
}

在考虑多种屏幕时，要注意它们的先后顺序min-width 786px是表示当屏幕大于768是要执行的CSS 如果将它放在min-width 1024px的前面，那么786这条语句就不会生效。
所以我们用min-width时，小的放上面大的在下面，同理如果是用max-width那么就是大的在上面，小的在下面
做移动开发时用device-width/device-height,比较好一点吧,因为有些手机浏览器默认会对页面进行一些缩放,所以按照设备宽高来进行匹配会更接近开发时所期望的效果;