---
title: Vue进阶题c
date: 2022-03-07 17:02:33
permalink: /pages/3da263/
categories:
  - 面试
  - Vue
tags:
  - 
---

# Vue进阶题c

对于有把握的事情，我们要谨慎面对；对于没有把握的事情，我们要微笑面对；

- 位运算 shapeFlag
- 对于 Vue3 的计算属性 computed 该如何理解

<!-- more -->

## 位运算 shapeFlag

使用位运算，运算效率快。

按位与 & 都为 1 才为 1
按位或 | 有 1 就为 1
按位异或 ^ 相同为 0 不同为 1
`<<` 左移 相当于乘以 2
`>>` 右移 正数最高位补 0 负数最高位补 0 或 1 (补 0 是逻辑右移 补 1 是算术右移)

Vue3 中的 element、component 等都是通过 1 左移得来的。所以在判断 shapeFlag 的时候不等于自身的数全为 0

```js
export const enum ShapeFlags {
  ELEMENT = 1, 
  FUNCTIONAL_COMPONENT = 1 << 1,
  STATEFUL_COMPONENT = 1 << 2,
  TEXT_CHILDREN = 1 << 3,
  ARRAY_CHILDREN = 1 << 4,
  SLOTS_CHILDREN = 1 << 5,
  TELEPORT = 1 << 6,
  SUSPENSE = 1 << 7,
  COMPONENT_SHOULD_KEEP_ALIVE = 1 << 8,
  COMPONENT_KEPT_ALIVE = 1 << 9,
  COMPONENT = ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT
}
```

## 对于 Vue3 的计算属性 computed 该如何理解

- 延迟计算，只有我们访问计算属性的时候，它才会真正执行 computed getter 函数进行计算
  - 依赖的响应式值发生了变化，只是把 _dirty 变为了 true，计算属性不会立即更新，只有当计算属性再次被访问的时候才会重新计算值
- 缓存，它内部会缓存上次的计算结果 _value，而且只有 _dirty 为 true 时才会重新计算

计算属性的优势是：只要它依赖的响应式数据不变化，就可以使用缓存的 _value，而不用每次渲染组件时都执行函数进行计算，这是典型的空间换时间的优化思想。

```js
const a = ref(1)

const b = computed(()=>{
  return a.value + 1
})

a.value ++
```

> 内部实现简要：computed 内部会有一个 _dirty 属性表示是否为脏数据为 true 的时候才会更新。第一次 _dirty 为 true 所以会执行一次，求得 computed 再把 _dirty 变为 false，同时建立一个 effect，传入调度器函数。在这个过程中产生了两个不同的依赖。b 的依赖是 computed 创建的 effect，因为 a 又是响应式的值，getter 访问了所以也会收集 effect。当响应式的值 a 发生变化后，就需要去触发相关的依赖 effect。又因为 computed 在创建 effect 的时候传入了调度器函数，所以会先执行调度器函数。如果 _dirty 是 false 就变为 true 然后再派发依赖。在组件重新渲染的时候会再去访问 b，触发 getter，有因为 _dirty 是 true，所以会重新计算 b 的值。

