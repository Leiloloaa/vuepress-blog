---
title: 3月准备-Vue
date: 2022-02-10 15:50:04
permalink: /pages/094acc/
categories:
  - 面试
tags:
  - 
---

# Vue

## Vue3

### Vue3 设计目标是什么？

**更小、更快、更友好、优化方案**

Vue2 的痛点：
- 随着功能的增长，复杂组件的代码变得越来越难以维护
- 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制
- 类型推断不够友好
- `bundle`的时间太久了

Vue3 的优势：
- options API 改成 composition(组合) API，解决了上下反复横跳的问题
- 使用 hooks 替换 mixin
- 引入的 typescript
- 引入tree-shaking，没用到的模块都被摇掉，仅打包需要的，使打包的整体体积变小了
- 编译方面
  - diff算法优化
  - 静态提升
  - 事件监听缓存
  - SSR 优化

**优化方案**

一切都是以性能为前提的最优方案，大体分成三个方面

- 源码
  - 通过 monorepo 的方式维护，模块拆分更细化，职责划分更明确，另外一些 package（比如 reactivity 响应式库）是可以独立于 Vue 使用的。
- 性能
  - 体积优化
  - 编译优化
  - 数据劫持优化
    - 使用 Proxy 替换 Object.defineProperty
- 语法 API
  - 优化逻辑组织
    - composition API
  - 优化逻辑复用
    - 使用 hooks 替换 mixin
    - mixin 带来的问题：命名冲突和数据来源不清晰

### Vue3 性能提升主要是通过哪几方面体现的？

- 编译阶段做了优化
- 源码体积缩小了
- 响应式原理实现方式改变了

**编译阶段**

- diff 算法优化
  - 增加了静态标记
  - PatchFlags 枚举了多种类型
  - Patch 的时候使用位运算，进一步提高性能
- 静态提升
  - 不参与更新的元素，会静态提升，只会创建一次，渲染的时候复用
  - 更新会调用 render 函数，放置在 render 函数之外即可
- 事件监听缓存
  - 默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化
  - 开启事件监听缓存后，没有了静态标记，diff 的时候就可以直接使用
- SSR 优化
  - 当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染

**源码体积**

- 移除了一些不常用的 API
- Tree Shanking 对于任何一个函数，仅仅在用到的时候才会打包，没用到的模块都会被摇调

**响应式系统**

- Vue2 采用 defineProperty 来劫持整个对象，然后进行深度的遍历，给每个属性添加 getter 和 setter，实现响应式
- Vue3 采用 proxy 重写了响应式系统，因为 proxy 可以对整个对象进行监听


### Vue3 为什么要用 Proxy API 替代 defineProperty API?

- Proxy 可以代理整个对象，并且返回一个新的对象，而


## Vue2