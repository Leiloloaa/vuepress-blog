---
title: 深信服面试记录
date: 2022-02-28 20:20:51
permalink: /pages/17041e/
categories:
  - 面试
  - 面试记录
tags:
  - 
---

# 深信服面试记录

面试官不扯源码，导致自己处于被动，因为自己这些日子准备都是基础知识，框架的 api 方面很欠缺，也基本没有问到 Vue3。及时的调整自己前行的方向，加油！

<!-- more -->

## react 生命周期函数

- 挂载阶段
  - constructor
  - render
  - componentDidMount
- 更新阶段
  - shouldComponentUpdate
  - render
  - componentDidUpdate
- 卸载阶段
  - componentWillUnmount
  - 会在这个里面清除定时器之类的

废弃了 componentWillMount 和 componentWillUpdate，因为引入的 fiber，react 花了两年的时间重构。

## react 类组件和函数组件的区别

函数组件的诞生是为了解决类组件的一些问题
比如说 this 的指向问题
- 在 React 中 Props 是 不可变(immutable)的，所以他们永远不会改变。
- 而 this 是而且永远是 可变(mutable)的。

## Vue hook 和 React hook 解决了什么问题

每调用 useHook 一次都会生成一份独立的状态

通过自定义hook能够更好的封装我们的功能

编写hooks为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅

hooks的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在我们日常使用中，使用hooks能够解决大多数问题，并且还拥有代码复用机制，因此优先考虑hooks

React

在不编写 class 的情况下是哟你 state 以及其他的 react 特性

为什么要用 hook
难以重用 和共享组件中与转态相关的逻辑
逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面
类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题
由于业务变动，函数组件不得不改为类组件等等

vue

mixins 不能相互消费和使用状态，但 Hooks 可以。这意味着如果我们需要链式封装逻辑，可以使用 Hooks

Hooks 为什么被提出？就 React 而言，最初的问题背景是这样的：

在表达状态概念时，类 是最常见的组织形式。类本身存在一些问题，比如绑定关系冗长、复杂，导致不易读，This 的指向总会让人摸不清头脑；

不仅如此，在重用方面，使用渲染工具或高阶组件类的模式很常见，但这样容易陷入 “pyramid of doom” （末日金字塔），可以将它理解为过度的嵌套关系；

Hooks 就是来解决这些问题的；Hooks 允许我们使用函数调用来定义组件的状态逻辑，这些函数有更强的组合性、重用性；同时，仍然可以进行状态的访问和维护；

## Vue 中组件间的通信方式以及何时使用

重点 ref 和 eventBus 事件中心 发布订阅模式

ref 可以获取 子组件的 dom 元素 以及获取子组件的变量和方法

this.$bus.$emit('nameOfEvent', { ... pass some event data ...});

this.$bus.$on('nameOfEvent',($event) => {
  // ...
})

## react 用过哪些钩子函数、

常用的就是 useState 是放回了一个数组、useEffect

在函数组件中通过useState实现函数内部维护state，参数为state默认的值，返回值是一个数组，第一个值为当前的state，第二个值为更新state的函数

useEffect可以让我们在函数组件中进行一些带有副作用的操作

useEffect第一个参数接受一个回调函数，默认情况下，useEffect会在第一次渲染和更新之后都会执行，相当于在componentDidMount和componentDidUpdate两个生命周期函数中执行回调

useReducer
useCallback
useMemo
useRef

## useEffect 的第二个参数？

useEffect 相当于 componentDidMount 和 componentWillUnmount

useEffect 函数里面如果放回的是一个 回调函数就相当于是 componentWillMount

useEffect 规则
在每次 render 之后执行
接受第二个参数来控制跳过执行，下次 render 后如果指定的值没有变化就不会执行
useEffect 是在 render 之后浏览器已经渲染结束才执行

不传参数的话 每次更新都会调用

传入 空数组，等同于类组件中的 componentDidMount

## 在哪个生命周期函数里面调用接口

异步请求在哪个阶段都可以调用，因为会先执行完生命周期的钩子函数之后，才会执行异步函数，但如果考虑用户体验方面的话，在 created 中调用异步请求最佳，用户就越早感知页面的已加载，毕竟越早获取数据，在 mounted 实例挂载的时候就越及时。
 
## 你是如何使用 Redux

用户信息，鉴权

## 封装 localStorage 的实效性有什么意义

购物车使用 localStorage 封装了时效性，也就是大概了做了一个清除购物车的机制

## 状态码 304

304 状态码是对客户端有缓存情况下服务端的一种响应

强缓存：
  - expires 时间点之前
  - cache-control 多少秒有效
协商缓存：
  - last-Modified 时间戳
  - etag hash
  - 请求时会带上 if-modified-since 或者是 if-none-match 看缓存是否命中

## Vue2 中定义 时间过滤器 以及更好的方式是什么 Vue3 为什么要抛弃过滤器属性

dayjs vs momentjs

## 兼容性问题

- ios 日期转换 Nan 问题
  - 具体就是，new Date('2020-11-12 00:00:00')在ios中会为NAN
  - 解决方案：用new Date('2020/11/12 00:00:00')的日期格式，或者写个正则转换
- 键盘遮挡输入框问题
  - input 获取焦点弹出系统虚拟键盘时，挡住 input
  - 获取输入宽的 dom 然后设置 一个 定时器 并且设置 scrollIntoView(true) 会滚动元素的父容器，使被调用scrollIntoView()的元素对用户可见
- 安卓部分版本input的placeholder偏上
  - input的line-height设为normal
  input{
      line-height:normal;
  }

## taro 和 uniApp 区别

讨论技术选型的时候，这两者都在范围内，两者能够实现的多端的产品也差不多。但是为了扩展团队的技术栈，同时不新增新的编译器，所以就选择了 Taro + React 的方式开发

uni-app 开发简单，小项目效率高
Taro 3 开发流程稍微复杂一点，但复杂项目的支持度会稍好

## 如何做到 css 响应式

- 媒体查询
  - 通过不同的设备宽度来设置
- rem 布局
  - rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size 相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size 的值，那么以rem为固定单位的元素的大小也会发生响应的变化。
  - 再根据 媒体查询
  - /* pc width > 1100px */
    html{ font-size: 100%;} // 这里的字体是16px=1rem
    body {
        background-color: yellow;
        font-size: 1.5rem;
    }
    /* ipad pro */
    @media screen and (max-width: 1024px) {
        body {
          background-color: #FF00FF;
          font-size: 1.4rem;
        }
    }
- 使用 vw 和 vh 视口
- 使用 postcss js插件
  - 使用 vite 配置 post.config.js 文件
  - 内部是会将你写的 px 转换成 rem

## 项目的优化点

- 抽离代码、封装公共函数和组件
- 合理的利用 v-if 和 v-show
- 静态资源的缓存
- 对于一些特定的场景使用 节流和防抖
- 路由懒加载
- 图片懒加载
- 使用图片的时候进行图片的压缩
  - 使用 库 lrz
  - 使用 canvas 减低图片的质量 重画图像 调用 canvas 的 toDataURL 方法压缩
- Tree-shaking 的含义就是只导入所需要的
- 对于时间的处理 使用 dayjs 2kb
- 注册了时间需要在组件销毁的时候删除事件

## 数组遍历方法

- for
- for...in 循环：只能获得对象的键名，不能获得键值
- for...of 循环：允许遍历获得键值
  - 只有部署了 iterator 接口的对象才可以使用
  - 无论是 for...in 还是 for...of 都不能遍历出 Symbol 类型的值，遍历 Symbol 类型的值需要用 Object.getOwnPropertySymbols() 方法
- forEach
  - 同步遍历
  - 不会返回新数组
- filter
  - 过滤
  - 返回一个满足条件新数组
- map
  - 会返回一个新数组
- some
  - 返回一个 Boolean
  - 如果有一个满足条件就会返回 true
- every
  - 返回一个 Boolean
  - 全部满足条件才会放回 true
- reduce
  - 正序遍历
  - 第二个参数是初始值，不传就是 0
- reduceRight  
  - 倒叙遍历

## git 工作流程 多人协作 git workflow

新建分支 提交修改 创建PR 代码评审 部署 合并分支

多人协作的话，会有多个分支，比如：开发环境分支、测试环境分支、线上环境分支。

### git add .  是什么意思？我可不可以提交 修改的几个文件？

git add .  会把你所有的改变会保存在缓存区 可以修改单独的文件 git add readme 加文件名就可以了

git restore --staged file.txt 就可以剔除文件 不加入缓存区中
git rm 就可以删除

git init
git config user.name
git config user.email
git remote add origin 来关联远程仓库

### git push 之前为什么先 git pull

因为要对比一下 本地分支 和 远程分支 是否一直，如果不一致的话 要先解决冲突 再提交

如果是 分支合并的话 就是提交 pr 然后代码评审 解决冲突 再合并

Pull Request 是一种通知机制。 你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是Pull Request。

高级 
git log
git config --global alias.ci "commit" // 取别名