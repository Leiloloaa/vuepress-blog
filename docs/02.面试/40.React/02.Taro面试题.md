---
title: Taro面试题
date: 2021-09-26 13:52:33
permalink: /pages/15e26e/
categories:
  - 面试
  - React
tags:
  - 
---

## hooks用过吗？聊聊 react 中 class 组件和函数组件的区别？

- class组件：state和props都是固定的地址
- 函数式组件：state和props每次都会跟着渲染更新而更新

## 说说 React中的setState执行机制

- 在组件生命周期或 React 合成事件中，setState 是异步
  - 如果想要立即获取参数，可以传入第二个回调函数，在这里面就能获取到最新的值。
- 在 setTimeout 或者原生 dom 事件中，setState 是同步

## 说说微信小程序的生命周期函数有哪些？

小程序中，生命周期主要分成了三部分：

- 应用的生命周期
  - 小程序的生命周期函数是在 app.js 里面调用的，通过 App(Object) 函数用来注册一个小程序，指定其小程序的生命周期回调
- 页面的生命周期
  - 页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数，同样通过App(Object)函数用来注册一个页面
- 组件的生命周期
  - 组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过Component(Object)进行注册组件

用的多得是`页面生命周期`

生命周期	说明	作用
onLoad	生命周期回调—监听页面加载	发送请求获取数据
onShow	生命周期回调—监听页面显示	请求数据
onReady	生命周期回调—监听页面初次渲染完成	获取页面元素（少用）
onHide	生命周期回调—监听页面隐藏	终止任务，如定时器或者播放音乐
onUnload	生命周期回调—监听页面卸载	终止任务

**⻚⾯⽣命周期的执行过程**

- ⼩程序注册完成后，加载⻚⾯，触发 onLoad ⽅法
- ⻚⾯载⼊后触发 onShow ⽅法，显示⻚⾯
- ⾸次显示⻚⾯，会触发 onReady ⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次
- 当⼩程序后台运⾏或跳转到其他⻚⾯时，触发 onHide ⽅法
- 当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发 onShow ⽅法
- 当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚ wx.navigateBack()，触发 onUnload

## 说说微信小程序中路由跳转的方式有哪些？区别？

- wx.navigateTo(Object)
  - 保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面
- wx.redirectTo(Object)
  - 用于关闭当前页面，跳转到应用内的某个页面
- wx.switchTab(Object)
  - 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
- wx.navigateBack(Object)
  - wx.navigateBack() 用于关闭当前页面，并返回上一页面或多级页面，开发者可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层则设置对象的delta属性即可
- wx.reLaunch(Object)
  - 关闭所有页面，打开到应用内的某个页面，返回的时候跳到首页

## 说说微信小程序的登录流程？

![](https://camo.githubusercontent.com/f655d7f73c2488145d0459e6e6307146dd9cc726e8fc4f3768e6cb7426928afe/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f63336366626237302d333432382d313165632d386536342d3931666465633066303561312e706e67)

## 说说微信小程序的实现原理？

小程序选择了 Hybrid 的渲染方式，将视图层和逻辑层是分开的，双线程同时运行，视图层的界面使用 WebView 进行渲染，逻辑层运行在 JSCore 中。

![](https://camo.githubusercontent.com/be96758bfa4fe9f01f040e26fbb8140fb033da104158e3ee6cbceff39f656ee5/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f34653332326535302d333732322d313165632d386536342d3931666465633066303561312e706e67)

**通信**

小程序在渲染层，宿主环境会把 wxml 转化成对应的 JS 对象

在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的 Dom 树上，渲染出正确的视图

![](https://camo.githubusercontent.com/28102d1611b1263818ee3c4aee8db5ea96c8227819159d93b73fc19efff7ad05/68747470733a2f2f7374617469632e7675652d6a732e636f6d2f35393438656431302d333732322d313165632d613735322d3735373233613634653866352e706e67)

**运行机制**

小程序启动运行两种情况：

- 冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动
- 热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动

当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁

每次冷启动时，都会检查是否有更新版本，如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上

## 你为什么要使用 Taro？Taro 有什么优势？

Taro 是遵循 React 语法规范的多端开发方案。小程序原生的开发方式不够友好，或者说不够工程化。

- 一个页面4个文件，开发时要来回切换
- 无法直接使用 Less、Sass 等 css 扩展语言
- 模板语法像 Vue，但是又没有那么多的语法糖

Taro 的优势在于能让我们在书写更有效率的代码、拥有更丰富的生态的同时，还带来了不错的性能。

小程序


说说小程序的三层架构


拆分逻辑层和渲染层有什么优势和劣势


小程序框架和普通H5框架的区别（比如Taro和RN）


小程序在安卓和iOS上的区别


为什么要用Taro？Taro是如何实现跨端的？

模版转换
taro首先要实现的就是进行模版转换，把 JSX 语法转换成可以在小程序运行的字符串模板。

模版转换的实现：
模版转换主要是通过静态编译实现的，分为解析、转换、生成，三个阶段。

解析过程：babel 的核心编译器 babylon 是支持对 JSX 语法解析的，taro框架利用这个编译器，将JSX通过词法、语法分析，生成抽象语法树。

非常幸运的是 babel 的核心编译器 babylon 是支持对 JSX 语法的解析的，我们可以直接利用它来帮我们构造 AST，而我们需要专注的核心就是如何对 AST 进行转换操作，得出我们需要的新 AST，再将新 AST 进行递归遍历，生成小程序的模板。

转换过程：针对已经生成的AST（抽象语法树），taro框架会使用已经定义好的转换操作以及多端的组件库规则对它进行转换修改。

经@tarojs/transformer-wx转换，输出微信小程序模板：
@tarojs/components：支持Web环境Nerv组件库，通过编译替换为目标平台的原生标签/组件
@tarojs/taro-components-rn：支持ReactNative环境的React组件库
生成过程：将新 AST 进行递归遍历，生成小程序的模板。

2、逻辑转换
除了模版转换，还需要进行逻辑代码的转换，由于各端api存在差异，如网络请求，数据缓存等，所以为了弥补不同端的差异，Taro定制了统一的 API 标准，同时还为不同的端编写了相应的运行时框架，这些API可以直接使用，不用关心当前平台是否支持，因为运行时框架会抹平这些API差异。

组件库以及端能力都是依靠不同的端做不同实现来抹平差异

逻辑转换的实现：

运行时框架负责适配各端能力，以支持跑在上面的Taro业务代码，主要有3个作用：

适配组件化方案、配置选项等基础API

适配平台能力相关的API（如网络请求、支付、拍照等）

提供一些应用级的特性，如事件总线（Taro.Events、Taro.eventCenter）、运行环境相关的API（Taro.getEnv()、Taro.ENV_TYPE）、UI适配方案（Taro.initPxTransform()）等

实现上，@tarojs/taro是API适配的统一入口，编译时分平台替换：
@tarojs/taro：只是一层空壳，提供API签名

平台适配相关的package有6个：
@tarojs/taro-alipay：适配支付宝小程序
@tarojs/taro-h5：适配Web
@tarojs/taro-rn：适配ReactNative
@tarojs/taro-swan：适配百度小程序
@tarojs/taro-tt：适配头条小程序
@tarojs/taro-qapp：适配快应用

taro通过模版转换和逻辑转换，实现了跨平台多端构建小程序。

Taro是如何兼容React和Vue的


Taro3和Taro2的区别


Taro的优化方案


小程序体积压缩的方案

