---
title: 3月准备-JS篇
date: 2022-02-10 09:16:17
permalink: /pages/3a80ad/
categories:
  - 面试
tags:
  - 
---

# JS篇

## 你是如何看待 es6 中的 module ？

模块，是能够单独命名并独立地完成一定功能的程序语句的集合（即程序代码和数据结构的集合体）。

**为什么需要模块化**

- 代码抽象
- 代码封装
- 代码复用
- 依赖管理

**如果没有模块化，我们代码会怎样？**

- 变量和方法不容易维护，容易污染全局作用域
- 加载资源的方式通过script标签从上到下
- 依赖的环境主观逻辑偏重，代码较多就会比较复杂
- 大型项目资源难以维护，特别是多人合作的情况下，资源的引入会让人奔溃

**JavaScript 程序模块化的机制**

- CommonJS (典型代表：node.js早期)
- AMD (典型代表：require.js)
  - 异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完成之后，这个回调函数才会运行
- CMD (典型代表：sea.js)
- ES6 module

CommonJS 和 AMD 模块，都只能在运行时确定模块。ES6 设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。

## CommonJS 和 ES6 模块的区别

- CommonJS 模块是运行时加载，ES6 Modules 是编译时输出接口
- CommonJS 是单个值导出，ES6模块化可以多个值导出
- CommonJS 输出是值的拷贝；ES6 Modules 输出的是值的引用，被输出模块的内部的改变会影响引用的改变
- CommonJS 导入的模块路径可以是一个表达式，因为它使用的是 require() 方法；而 ES6 Modules 只能是字符串
- CommonJS this 指向当前模块，ES6 Modules this 指向undefined

且 ES6 Modules 中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname

关于第一个差异，是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。


## 箭头函数的特点

- 没有 this，如果非要找，它的 this 不是运行时确定的，它的 this 在定义的时候就固定了
- 没有 arguments
- 不能作为构造函数，不能使用 new
- 使用 call、apply、bind 无效
- 没有原型 prototype
- 不能作为 Generator 函数，不能使用 yield 关键字

## Promise

从最开始的回调函数处理异步，到 Promise 处理异步，到 Generator 处理异步，再 async/await 处理异步，每一次的技术更新都使得 JavaScript 处理异步的方式更加优雅，从目前来看，async/await 被认为是异步处理的终极解决方案，让JS的异步处理越来越像同步任务。`异步编程的最高境界，就是根本不用关心它是不是异步`。

通过使用 Promise 来处理异步，比以往的回调函数看起来更加清晰了，解决了回调地狱的问题，Promise 的 then 的链式调用更能让人接受，也符合我们同步的思想。

特点：
- 对象的状态不受外界影响
  - Promise 对象代表一个异步操作，有三种状态：pending(进行中)，fulfilled(已成功)和reject(已失败)。只有异步操作的结果，可以决定当前是哪一种状态，任何其它操作都无法改变这个状态。这也是 Promise 承诺这个名字的由来。
- 一旦状态改变，就不会再变，任何时候都可以得到这个结果。
  - Promise对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。

缺点：
- Promise 的内部错误使用 try catch 捕获不到，只能用 then 的第二个回调或 catch 来捕获。
```js
let pro
try{
    pro = new Promise((resolve,reject) => {
        throw Error('err....')
    })
}catch(err){
    console.log('catch',err) // 不会打印
}
pro.catch(err=>{
    console.log('promise',err) // 会打印
})
```
- Promise 一旦新建就会立即执行，无法取消。

## 写一个function清除字符串前后的空格（兼容所有浏览器）?

```js
function trim(str) {
  if (str && typeof str === "string") {
    // \s 是空格  * 号代表字符可以不出现，也可以出现一次或者多次  
    // \s* 表示空格可以不出现也可以出现1次或多次
    // ^ 匹配开头的位置 $ 匹配结尾的位置
    // 如果是匹配本身的话 要使用转移字符 加上 \
    return str.replace(/(^\s*)|(\s*)$/g, "");
  }
}
```

PS：为什么正则表达式能够兼容所有浏览器；因为JS引擎中就包含了正则引擎，IE浏览器和非IE浏览器都包含了JS引擎，所以都兼容；只要是JS原生支持的，基本都能够兼容所有浏览器。因为浏览器都要符合W3C制定的标准。

## 经典面试题

```js
for(var i=0;i<5;i++){
  setTimeout(function(){
    console.log(i)
  },i*1000)
}
```

输出结果是什么，并且如何在这里使用闭包？
PS：输出的是5个5；setTimeout的异步的，for循环是同步的，执行完for循环后i=5，但是开辟了5个setTimeout，所以会输出5个5
将var 改为 let 意思是每次迭代创建一个唯一的作用域，使用闭包来防止这个问题，并将改变量的每个唯一值存储在其作用域中

## console.log(typeof typeof 1)输出的是什么？

string

PS：从右边开始 typeof 1 为 number
typeof number 为string

## 原型

```js
// new 构造器函数调用注重的是新创建的这个对象的内存地址
let myFun = new MyFun()
// 它属于实例
myFun.__proto__
// 它属于构造器
MyFun.prototype
myFun.__proto__ === MyFun.prototype
```

![](http://66.152.176.25:8000/home/images/js/123.png)

## 说说对设计模式的理解？常见的设计模式有哪些？

在软件工程中，设计模式是对软件设计中普遍存在的各种问题所提出的解决方案。

**常见的设计模式**

- 单例模式
  - Vue2 就是单例模式，全局只有一个 Vue 实例，jQuery 也是单例模式
  - 好处就是只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象
  - 弊端就是不利于分包以及 TreeSharking 摇掉无用的代码
- 工厂模式
- 策略模式
- 代理模式
- 观察者模式
  - 观察者模式本身只需要2个角色便可成型，即观察者和被观察者
  - 观察者模式定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新
- 发布-订阅模式
  - Vue2 的响应式就是发布-订阅模式
  - 发布订阅需要至少3个角色来组成，包括发布者、订阅者和发布订阅中心，其中发布订阅中心是重点
  - 与观察者模式相比，发布订阅核心基于一个中心来建立整个体系。其中发布者和订阅者不直接进行通信，而是发布者将要发布的消息交由中心管理，订阅者也是根据自己的情况，按需订阅中心中的消息。

> 观察者模式：某公司给自己员工发月饼发粽子，是由公司的行政部门发送的，这件事不适合交给第三方，原因是“公司”和“员工”是一个整体
> 发布-订阅模式：某公司要给其他人发各种快递，因为“公司”和“其他人”是独立的，其唯一的桥梁是“快递”，所以这件事适合交给第三方快递公司解决

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19b670df6cb54c4ebdc17a114b5dc97c~tplv-k3u1fbpfcp-watermark.awebp)