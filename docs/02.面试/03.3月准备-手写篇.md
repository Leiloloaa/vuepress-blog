---
title: 3月准备-手写篇
date: 2022-02-10 10:36:03
permalink: /pages/dc827b/
categories:
  - 面试
  - vue3 diff 算法
tags:
  - 
---


# 手写篇

**目录**
- 节流、防抖
- new、call、apply、bind
- instanceof、typeof

<!-- more -->

## 节流与防抖

- 节流：频繁的触发一个事件，在一段时间内只触发一次；
  - 例如：滚动刷新、地铁刷卡进站闸机打开时间是固定的。
- 防抖：频繁的触发一个事件，在一段时间内只触发最后一次；
  - 例如：点击按钮、公交乘车司机总是根据最后一个乘客上车才会关门。

```js
// 节流函数
function throttle (fn,delay) {
  let timer = null
  return function (){
    if(timer) return
    timer = setTimeout(() => {
      fn()
      clearTimeOut(timer)
      timer = null
    }, delay);
  }
}

// 防抖函数
function debounce (fn,delay){
  let timer= null
  return function (){
    if(timer){
      clearTimeOut(timer)
      timer = null
    }
    timer = setTimeout(()=>{
      fn()
      clearTimeOut(timer)
      timer = null
    }, delay)
  }
}
```

## new、call、apply、bind

- new：创建实例的时候需要使用 new 关键字
- call、apply：都是修改 this 的指向，前者传入多个参数，后者传入的是数组，且都是立即执行
- bind：修改 this 的指向，并返回一个函数，并且支持柯里化传参，等待执行

```js
// new
// 四步：创建一个空对象、继承这个 fn 的原型 实例的__proto__ 是指向 prototype 的、绑定 this 并执行这个函数、返回这个实例对象
function myNew (fn,...arg) {
  let obj = {}
  obj.__proto__ = fn.prototype
  fn.apply(this,[...arg])
  return obj
}
```

```js
// call、apply
// 修改 this 指向、立即执行，call 是接受参数而 apply 是接受数组
Function.prototype.myCall = function (context) {
  // 将函数设为对象的属性
  // 注意：非严格模式下, 
  //   指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中就是 window 对象)
  //   值为原始值(数字，字符串，布尔值)的 this 会指向该原始值的自动包装对象(用 Object() 转换）
  context = context ? Object(context) : window;
  // 把函数绑定到 传入的 context 身上
  context.fn = this;
  // 执行该函数
  let args = [...arguments].slice(1);
  let result = context.fn(...args);

  // 删除该函数
  delete context.fn;
  // 注意：函数是可以有返回值的
  return result;
}

Function.prototype.myApply = function(context, arr) {
  // 处理 context
  context = context ? Object(context) : window;
  // 将函数绑定到对象上
  context.fn = this;
  // 执行函数
  let result
  if (!arr) {
      result = context.fn()
  } else {
      result = context.fn(...arr)
  }
  // 删除函数
  delete context.fn
  return result
}
```

```js
// bind 实现 函数柯里化 部分
// 步骤
// 1、this 指向调用者
// 2、传入参数
// 3、返回一个函数
// 4、柯里化接收剩余参数
Function.prototype.myBind = function(context) {
  // 如果不是函数直接报错
  if (typeof this !== 'function') {
      throw new Error('not is Function')
  }
  // this 指向调用者
  let self = this;
  // 传入参数
  // let args = Array.prototype.slice.call(arguments, 1);
  let args = [...arguments].slice(1);
  // 返回一个函数
  return function() {
      // 柯里化接收参数 此时的参数 arguments 是指 bind 返回后的函数接收的参数
      let bindArgs = [...arguments]
      return self.apply(context, args.concat(bindArgs))
  }
}
```

## instanceof、typeof

typeof 与 instanceof 都是判断数据类型的方法，区别如下：
- typeof 会返回一个变量的基本类型，instanceof 返回的是一个布尔值
- instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型
- 而 typeof 也存在弊端，它虽然可以判断基础数据类型（null 除外），但是引用数据类型中，除了 function 类型以外，其他的也无法判断

额外说明：typeof null 判定为 object，是 javascript 早期设置的 bug，因为 javascript 认为，二进制的前 3 位是 0，就表示为对象；而 null 全是 0，自然就判定错了。

```js
function myInstanceof(target, origin){
  while(target){
    if(target.__proto__ === origin.prototype){
      return true
    }
    target = target.__proto__
  }
  return false
}
```

```js
function myTypeof (target) {
  let type = Object.prototype.toString.call(target).slice(8,-1).toLowerCase()
  let map = {
    'number': true,
    'string': true,
    'boolean': true,
    'undefined': true,
    'symbol': true,
    'bigint': true,
    'function': true
  }
  return map[type] ? type : 'object'
}
```

如果需要通用检测数据类型，可以采用 Object.prototype.toString，调用该方法，统一返回格式`[object Xxx]`的字符串

```js
function getType(obj) {
  let type = typeof obj;
  if (type !== "object") {
    return type;
  }
  // 对于 typeof 返回结果是 object 的，再进行如下的判断
  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
}
```