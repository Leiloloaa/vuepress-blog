---
title: 6张图、20分钟，包你学会 Vue3 是如何最优化计算 vdom
date: 2022-01-11 15:44:55
permalink: /pages/2254c7/
categories:
  - 面试
  - vue3 diff 算法
tags:
  - 
---

# 6 张图 20分钟 包你学会 Vue3 是如何最优化计算 vdom

想必你已经听过 Vue3 的`左右互博之术`（如果没有听过，可以点击 [传送门]() 深入了解一下），为了增强我们的`内功`，本文讨论当你通过算法得出乱序部分之后还要做些什么才能让改变尽可能小，让性能消耗变得更便宜~~~

如图，你通过`双端对比`（三个指针，通过左序遍历和右序遍历确定变动的位置）已经找到了乱序的部分

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de97c29726fb4b3aa651b2b140d8db59~tplv-k3u1fbpfcp-watermark.image?)

思考一下，新老节点对比无非是以下三种情况：

- 1、新的比老的长 => 增加
- 2、新的比老的短 => 删除
- 3、新的和老的一样长 => 移动或增加或删除

**前情回顾**

- i 表示左序遍历 新节点与老节点对比 变动的位置 初始值为 0
- e1 表示右序遍历 老节点与新节点对比 变动的位置 初始值为 老节点最后一位的索引值
- e2 表示右序遍历 新节点与老节点对比 变动的位置 初始值为 新节点最后一位的索引值

用代码表示

```js
if(i>e1){
  // 新的比老的长
  ...
}else if(i>e2){
  // 新的比老的短
  ...
}else{
  // 一样长
}
```

## 新的虚拟节点比老的虚拟节点长

新的节点更长，肯定是需要增加的，所以循环的条件就是 i > e1 并且 i 是小于或等于 e2，如图所示：

代码实现：

```js
// c1 是老节点树
// c2 是新节点树 
// len2 = c2.length -1 
if (i > e1) {
  if (i <= e2) {
    // 左侧 可以直接加在末尾
    // 右侧的话 我们就需要引入一个 概念 锚点 的概念
    // 通过 anchor 锚点 我们将新建的元素插入的指定的位置
    const nextPos = e2 + 1
    // 如果 e2 + 1 大于 c2 的 length 那就是最后一个 否则就是最先的元素
    // 锚点是一个 元素
    const anchor = nextPos < len2 ? c2[nextPos].el : null
    while (i <= e2) {
      // 再往深层的比较节点
      // patch
      i++
    }
  }
}
```

增加的话有两种情况，如图所示：

## 老的虚拟节点比新的虚拟节点长

老的更长所以是删除节点

```js
if (i > e2) {
  // 老的比新的多 删除
  // e1 就是 老的 最后一个
  while (i <= e1) {
    // 移除元素
    hostRemove(c1[i].el);
    i++;
  }
} 
```

## 新老节点一样长，处理中间乱序部分

两个节点树长度是一样的，我们可以通过遍历老节点，然后同时遍历新节点，检查是否在新的里面存在，此时时间复杂度为 O(n*n)；显然不是最优，为了优化性能，我们可以为新的节点建立一个映射表，只要根据 key 去查是否存在；

```js
let s1 = i // i 是停止的位置 差异开始的地方
let s2 = i
// 建立新节点的映射表
const keyToNewIndexMap = new Map()

// 循环 e2
for (let i = s2; i <= e2; i++) {
  const nextChild = c2[i]; // c2 是新节点
  keyToNewIndexMap.set(nextChild.key, i)
}
```

建立完映射表之后，我们在循环 e1（因为 e1 是老节点，我们所有的步骤都是为了减少 dom 的操作，所以我们要对比新老节点，改动其实是在 e1，对照 e2 改 e1），

```js
// 循环 e1
for (let i = s1; i <= e1; i++) {
  const prevChild = c1[i]; // c1 是老节点

  let newIndex
  if (prevChild.key !== null) {
    // 用户输入 key
    newIndex = keyToNewIndexMap.get(prevChild.key)
  } else {
    // 用户没有输入 key
    for (let j = s2; j < e2; j++) {
      // 判断节点是否相同
      if (isSomeVNodeType(prevChild, c2[j])) {
        newIndex = j;
        break;
      }
    }
  }

  if (newIndex === undefined) {
    hostRemove(prevChild.el)
  } else {
      // 在深层次的比较
      // patch
  }
}
```

上方的代码，咱们可以优化一下

```js
// 如果新的节点少于老的节点，当遍历完新的之后，就不需要再遍历了
// 通过一个总数和一个遍历次数 来优化
// 要遍历的数量
const toBePatched = e2 - s2 + 1
// 已经遍历的数量
let patched = 0
// 建立新节点的映射表
const keyToNewIndexMap = new Map()
// 新建一个定长数组(需要变动的长度) 性能是最好的 来确定新老之间索引关系 我们要查到最长递增的子序列 也就是索引值
const newIndexToOldIndexMap = new Array(toBePatched)
// 确定是否需要移动 只要后一个索引值小于前一个 就需要移动
let moved = false
let maxNewIndexSoFar = 0

// 循环 e1
for (let i = s1; i <= e1; i++) {
  const prevChild = c1[i];

  if (patched >= toBePatched) {
    hostRemove(prevChild.el)
    continue
  }

  let newIndex
  if (prevChild.key !== null) {
    // 用户输入 key
    newIndex = keyToNewIndexMap.get(prevChild.key)
  } else {
    // 用户没有输入 key
    for (let j = s2; j < e2; j++) {
      if (isSomeVNodeType(prevChild, c2[j])) {
        newIndex = j;
        break;
      }
    }
  }

  if (newIndex === undefined) {
    hostRemove(prevChild.el)
  } else {
    if (newIndex >= maxNewIndexSoFar) {
      maxNewIndexSoFar = newIndex
    } else {
      moved = true
    }

    // 实际上是等于 i 就可以 因为 0 表示不存在 所以 定义成 i + 1
    newIndexToOldIndexMap[newIndex - s2] = i + 1

    // 存在就再次深度对比
    patch(prevChild, c2[newIndex], container, parentComponent, null)
    // patch 完就证明已经遍历完一个新的节点
    patched++
  }
}
```

到这比一步，咱们就只剩调用最长递增子序列

```js
// 获取最长递增子序列 getSequence
const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : []

let j = increasingNewIndexSequence.length - 1
// 倒序的好处就是 能够确定稳定的位置
// ecdf
// cdef
// 如果是 从 f 开始就能确定 e 的位置
// 从最后开始就能依次确定位置
for (let i = toBePatched; i >= 0; i--) {
  const nextIndex = i + s2
  const nextChild = c2[nextIndex]
  const anchor = nextIndex + 1 < len2 ? c2[nextIndex + 1].el : null
  if (newIndexToOldIndexMap[i] === 0) {
    patch(null, nextChild, container, parentComponent, anchor)
  } else if (moved) {
    if (j < 0 || i !== increasingNewIndexSequence[j]) {
      // 移动位置 调用 insert
      hostInsert(nextChild.el, container, anchor)
    } else {
      j++
    }
  }
}
```

全部代码如下

```js
// 乱序部分
// 遍历老节点 然后检查在新的里面是否存在
// 方案一 同时遍历新的 时间复杂度 O(n*n)
// 方案二 新的节点建立一个映射表 时间复杂度 O(1) 只要根据 key 去查是否存在
// 为了性能最优 选则方案二
let s1 = i // i 是停止的位置 差异开始的地方
let s2 = i

// 如果新的节点少于老的节点，当遍历完新的之后，就不需要再遍历了
// 通过一个总数和一个遍历次数 来优化
// 要遍历的数量
const toBePatched = e2 - s2 + 1
// 已经遍历的数量
let patched = 0
// 建立新节点的映射表
const keyToNewIndexMap = new Map()
// 新建一个定长数组(需要变动的长度) 性能是最好的 来确定新老之间索引关系 我们要查到最长递增的子序列 也就是索引值
const newIndexToOldIndexMap = new Array(toBePatched)
// 确定是否需要移动 只要后一个索引值小于前一个 就需要移动
let moved = false
let maxNewIndexSoFar = 0
// 赋值
for (let i = 0; i < toBePatched; i++) {
  newIndexToOldIndexMap[i] = 0
}

// 循环 e2
for (let i = s2; i <= e2; i++) {
  const nextChild = c2[i];
  keyToNewIndexMap.set(nextChild.key, i)
}

// 循环 e1
for (let i = s1; i <= e1; i++) {
  const prevChild = c1[i];

  if (patched >= toBePatched) {
    hostRemove(prevChild.el)
    continue
  }

  let newIndex
  if (prevChild.key !== null) {
    // 用户输入 key
    newIndex = keyToNewIndexMap.get(prevChild.key)
  } else {
    // 用户没有输入 key
    for (let j = s2; j < e2; j++) {
      if (isSomeVNodeType(prevChild, c2[j])) {
        newIndex = j;
        break;
      }
    }
  }

  if (newIndex === undefined) {
    hostRemove(prevChild.el)
  } else {
    if (newIndex >= maxNewIndexSoFar) {
      maxNewIndexSoFar = newIndex
    } else {
      moved = true
    }

    // 实际上是等于 i 就可以 因为 0 表示不存在 所以 定义成 i + 1
    newIndexToOldIndexMap[newIndex - s2] = i + 1

    // 存在就再次深度对比
    patch(prevChild, c2[newIndex], container, parentComponent, null)
    // patch 完就证明已经遍历完一个新的节点
    patched++
  }
}

// 获取最长递增子序列
const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : []

let j = increasingNewIndexSequence.length - 1
// 倒序的好处就是 能够确定稳定的位置
// ecdf
// cdef
// 如果是 从 f 开始就能确定 e 的位置
// 从最后开始就能依次确定位置
for (let i = toBePatched; i >= 0; i--) {
  const nextIndex = i + s2
  const nextChild = c2[nextIndex]
  const anchor = nextIndex + 1 < len2 ? c2[nextIndex + 1].el : null
  if (newIndexToOldIndexMap[i] === 0) {
    patch(null, nextChild, container, parentComponent, anchor)
  } else if (moved) {
    if (j < 0 || i !== increasingNewIndexSequence[j]) {
      // 移动位置 调用 insert
      hostInsert(nextChild.el, container, anchor)
    } else {
      j++
    }
  }
}
```

## 写在最后

本文与各位读者谈论当确定新老几点变动的位置之后，如何将性能达到最优。笔者认为框架实现的思路方法值得咱们去深究、借鉴。另外，如果你想学习 Vue3 源码，推荐先入手 [mini-vue](https://github.com/cuixiaorui/mini-vue)，带你实现 Vue3 最简模型。