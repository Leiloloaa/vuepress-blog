---
title: 7张图、20分钟，包你学会 Vue3 最优化计算 vdom
date: 2022-01-11 15:44:55
permalink: /pages/2254c7/
categories:
  - 面试
  - vue3 diff 算法
tags:
  - 
---

# 7张图、20分钟，包你学会 Vue3 最优化计算 vdom

想必你已经听过 Vue3 的`左右互博之术`（如果没有听过，可以点击 [传送门](https://juejin.cn/post/7053996176051273765) 深入了解一下），为了增强我们的`内功`，本文讨论当你通过算法得出乱序部分之后还要做些什么才能让改变尽可能小，让性能消耗变得更便宜~~~

如图，你通过`双端对比`（三个指针，通过左序遍历和右序遍历确定变动的位置）已经找到了乱序的部分

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de97c29726fb4b3aa651b2b140d8db59~tplv-k3u1fbpfcp-watermark.image?)

思考一下，新老节点对比无非是以下三种情况：

- 1、新的比老的长 => 增加
- 2、新的比老的短 => 删除
- 3、新的和老的一样长 => 移动或增加或删除

老的虚拟节点有对应的真实 DOM，也就是已经渲染过的节点。而新的虚拟节点是一个对象，我们需要做的的就是`新老虚拟节点对比`，得出最小的差异，去更新真实的 DOM。

**前情回顾**

- i 表示左序遍历 新节点与老节点对比 变动的位置 初始值为 0
- e1 表示右序遍历 老节点与新节点对比 变动的位置 初始值为 老节点最后一位的索引值
- e2 表示右序遍历 新节点与老节点对比 变动的位置 初始值为 新节点最后一位的索引值

用代码表示

```js
if(i>e1){
  // 新的比老的长
  ...
}else if(i>e2){
  // 新的比老的短
  ...
}else{
  // 一样长
}
```

## 新的虚拟节点比老的虚拟节点长
新的节点更长，需要增加节点，所以循环的条件就是 i > e1 并且 i 是小于或等于 e2。

增加有两种情况，如图所示：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10aae6a641f44bd0ac4eb327a16cc900~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5450c68fc0d04077836a48780f395790~tplv-k3u1fbpfcp-watermark.image?)

代码实现：

```js
// c1 是老节点树
// c2 是新节点树 
// len2 = c2.length -1 
if (i > e1) {
  if (i <= e2) {
    // 左侧 可以直接加在末尾
    // 右侧的话 我们就需要引入一个 概念 锚点 的概念
    // 通过 anchor 锚点 我们将新建的元素插入的指定的位置
    const nextPos = e2 + 1
    // 如果 e2 + 1 大于 c2 的 length 那就是最后一个 否则就是最先的元素
    // 锚点是一个 元素
    const anchor = nextPos < len2 ? c2[nextPos].el : null
    while (i <= e2) {
      // 再往深层的比较节点
      // patch
      i++
    }
  }
}
```

## 老的虚拟节点比新的虚拟节点长

老的更长所以是删除节点，循环的条件就是 i <= e1，i 是从左侧开始变动的位置，e1 则是从右侧开始变动的位置。但是也两种情况，如下图所示：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/257112e6f99a4b31b67c58baf049a96a~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22ea952ac6194113b6d27d711802a9dc~tplv-k3u1fbpfcp-watermark.image?)

```js
if (i > e2) {
  // 老的比新的多 删除
  // e1 就是 老的 最后一个
  while (i <= e1) {
    // 移除元素
    hostRemove(c1[i].el);
    i++;
  }
} 
```

## 新老节点一样长，处理中间乱序部分

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4622ce3f2072405c85b848a0feaccc97~tplv-k3u1fbpfcp-watermark.image?)

我们根据这个例子来讨论，是不是只需要删除 e 和增加 y？cd 的位置相对稳定，重复利用即可！

既然两个节点树长度是一样的，我们可以通过遍历老节点，然后同时遍历新节点，检查是否在新的里面存在，此时时间复杂度为 O(n*n)；显然不是最优，为了优化性能，我们可以为新的节点建立一个映射表，只要根据 key 去查是否存在；

如下图，我们得知变动元素在老节点中的索引分别是 c:2 d:3 e:4

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6abdd7677c94492af02dee456d29994~tplv-k3u1fbpfcp-watermark.image?)

```js
let s1 = i // i 是停止的位置 差异开始的地方
let s2 = i
// 建立新节点的映射表
const keyToNewIndexMap = new Map()

// 循环 e2
for (let i = s2; i <= e2; i++) {
  const nextChild = c2[i]; // c2 是新节点
  keyToNewIndexMap.set(nextChild.key, i)
}
```

映射表如下

```js
{
  'y':2,
  'c':3,
  'd':4
}
```

建立完映射表之后，我们在循环 e1（因为 e1 是老节点，我们所有的步骤都是为了减少 dom 的操作，所以我们要对比新老节点，改动其实是在 e1，对照 e2 改 e1），

```js
// 循环 e1
for (let i = s1; i <= e1; i++) {
  const prevChild = c1[i]; // c1 是老节点

  let newIndex // 临时变量索引
  // 这里先只做简单的 key 值判断是否为同一个
  if (prevChild.key !== null) {
    // 用户输入了 key 那么 newIndex 就等于 映射表中 对应的索引值
    newIndex = keyToNewIndexMap.get(prevChild.key)
  } else {
    // 用户没有输入 key
    for (let j = s2; j < e2; j++) {
      if (isSomeVNodeType(prevChild, c2[j])) {
        // 如果相同的话 newIndex 就等于 老节点中的索引值 也就是 此时的 j
        newIndex = j;
        break;
      }
    }
  }
  
  // 上面几行代码所做的事情就是 拿到 新节点 在 老节点 对应的 索引值
  // 有两种情况 undefined 或 有值
  if (newIndex === undefined) {
    // 新节点中不存在老节点的话 就可以直接删除此元素了 
    hostRemove(prevChild.el)
  } else {
      // 存在就在次深层次的比较
      // patch  => prevChild 和 c2[newIndex]
  }
}
```

上方的代码，咱们可以优化一下

```js
// 如果新的节点少于老的节点，当遍历完新的之后，就不需要再遍历了
// 通过一个总数和一个遍历次数 来优化
// 要遍历的数量
const toBePatched = e2 - s2 + 1
// 已经遍历的数量
let patched = 0
// 建立新节点的映射表
const keyToNewIndexMap = new Map()
// 新建一个定长数组(需要变动的长度) 性能是最好的 来确定新老之间索引关系 我们要查到最长递增的子序列 也就是索引值
const newIndexToOldIndexMap = new Array(toBePatched)
// 确定是否需要移动 只要后一个索引值小于前一个 就需要移动
let moved = false
let maxNewIndexSoFar = 0

// 循环 e1
for (let i = s1; i <= e1; i++) {
  const prevChild = c1[i];

  if (patched >= toBePatched) {
    hostRemove(prevChild.el)
    continue
  }

  let newIndex
  if (prevChild.key !== null) {
    // 用户输入 key
    newIndex = keyToNewIndexMap.get(prevChild.key)
  } else {
    // 用户没有输入 key
    for (let j = s2; j < e2; j++) {
      if (isSomeVNodeType(prevChild, c2[j])) {
        newIndex = j;
        break;
      }
    }
  }

  if (newIndex === undefined) {
    hostRemove(prevChild.el)
  } else {
    if (newIndex >= maxNewIndexSoFar) {
      maxNewIndexSoFar = newIndex
    } else {
      moved = true
    }

    // 实际上是等于 i 就可以 因为 0 表示不存在 所以 定义成 i + 1
    newIndexToOldIndexMap[newIndex - s2] = i + 1

    // 存在就再次深度对比
    patch(prevChild, c2[newIndex], container, parentComponent, null)
    // patch 完就证明已经遍历完一个新的节点
    patched++
  }
}
```

到这一步，咱们就只剩调用最长递增子序列，来使调整尽可能少。

```js
// 获取最长递增子序列 getSequence
const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : []

let j = increasingNewIndexSequence.length - 1
// 倒序的好处就是 能够确定稳定的位置
// ecdf
// cdef
// 如果是 从 f 开始就能确定 e 的位置
// 从最后开始就能依次确定位置
for (let i = toBePatched; i >= 0; i--) {
  const nextIndex = i + s2
  const nextChild = c2[nextIndex]
  const anchor = nextIndex + 1 < len2 ? c2[nextIndex + 1].el : null
  if (newIndexToOldIndexMap[i] === 0) {
    patch(null, nextChild, container, parentComponent, anchor)
  } else if (moved) {
    if (j < 0 || i !== increasingNewIndexSequence[j]) {
      // 移动位置 调用 insert
      hostInsert(nextChild.el, container, anchor)
    } else {
      j++
    }
  }
}
```

## 写在最后

本文与各位讨论了当确定新老节点变动的位置之后，如何才能将性能达到最优。笔者认为框架实现的思路方法值得咱们去深究、借鉴。另外，如果你想学习 Vue3 源码，推荐先入手 [mini-vue](https://github.com/cuixiaorui/mini-vue)，带你实现 Vue3 最简模型。