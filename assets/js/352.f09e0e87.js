(window.webpackJsonp=window.webpackJsonp||[]).push([[352],{813:function(e,t,r){"use strict";r.r(t);var o=r(35),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"生命周期与钩子函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生命周期与钩子函数"}},[e._v("#")]),e._v(" 生命周期与钩子函数")]),e._v(" "),r("blockquote",[r("p",[e._v("Vue 是组件化编程，组件从（诞生）创建到（消亡）卸载的过程中会经历很多过程，这个就叫做生命周期。而钩子函数就是伴随着生命周期，给用户使用的函数，操控生命周期，主要是操控钩子函数。")])]),e._v(" "),r("h2",{attrs:{id:"vue3钩子函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue3钩子函数"}},[e._v("#")]),e._v(" Vue3钩子函数")]),e._v(" "),r("ul",[r("li",[e._v("setup() :开始创建组件之前，"),r("strong",[e._v("在beforeCreate和created之间执行")]),e._v("。创建的是data和method")]),e._v(" "),r("li",[e._v("onBeforeMount() : 组件挂载到节点上之前执行的函数。")]),e._v(" "),r("li",[e._v("onMounted() : 组件挂载完成后执行的函数。 // 这里才能拿到 dom 元素")]),e._v(" "),r("li",[e._v("onBeforeUpdate(): 组件更新之前执行的函数。")]),e._v(" "),r("li",[e._v("onUpdated(): 组件更新完成之后执行的函数。")]),e._v(" "),r("li",[e._v("onBeforeUnmount(): 组件卸载之前执行的函数。")]),e._v(" "),r("li",[e._v("onUnmounted(): 组件卸载完成后执行的函数")]),e._v(" "),r("li",[e._v("onActivated(): 被包含在"),r("keep-alive",[e._v("中的组件，会多出两个生命周期钩子函数。被激活时执行。")])],1),e._v(" "),r("li",[e._v("onDeactivated(): 比如从 A 组件，切换到 B 组件，A 组件消失时执行。")]),e._v(" "),r("li",[e._v("onErrorCaptured(): 当捕获一个来自子孙组件的异常时激活钩子函数（以后用到再讲，不好展现）。")])]),e._v(" "),r("blockquote",[r("p",[e._v("注：使用"),r("keep-alive",[e._v("组件会将数据保留在内存中，比如我们不想每次看到一个页面都重新加载数据，就可以使用"),r("keep-alive",[e._v("组件解决。")])],1)],1)]),e._v(" "),r("h2",{attrs:{id:"vue2和vue3钩子函数对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue2和vue3钩子函数对比"}},[e._v("#")]),e._v(" Vue2和Vue3钩子函数对比")]),e._v(" "),r("ul",[r("li",[e._v("Vue2--------------vue3")]),e._v(" "),r("li",[e._v("beforeCreate  -> setup()")]),e._v(" "),r("li",[e._v("created       -> setup()")]),e._v(" "),r("li",[e._v("beforeMount   -> onBeforeMount")]),e._v(" "),r("li",[e._v("mounted       -> onMounted")]),e._v(" "),r("li",[e._v("beforeUpdate  -> onBeforeUpdate")]),e._v(" "),r("li",[e._v("updated       -> onUpdated")]),e._v(" "),r("li",[e._v("beforeDestroy -> onBeforeUnmount")]),e._v(" "),r("li",[e._v("destroyed     -> onUnmounted")]),e._v(" "),r("li",[e._v("activated     -> onActivated")]),e._v(" "),r("li",[e._v("deactivated   -> onDeactivated")]),e._v(" "),r("li",[e._v("errorCaptured -> onErrorCaptured")])]),e._v(" "),r("blockquote",[r("p",[e._v("通过这样对比，可以很容易的看出 vue3 的钩子函数基本是再 vue2 的基础上加了一个on,但也有两个钩子函数发生了变化。\nBeforeDestroy变成了onBeforeUnmount\ndestroyed变成了onUnmounted\n尤大神的介绍是mount比Destroy更形象，也和beforeMount相对应。\n另外Vue3.x还增加了onRenderTracked和onRenderTriggered函数")])]),e._v(" "),r("h2",{attrs:{id:"注意"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#注意"}},[e._v("#")]),e._v(" 注意")]),e._v(" "),r("blockquote",[r("p",[e._v("Vue3能够向下兼容，所以Vue2中的钩子函数也是可以使用的。但是如果你使用的是 Vue3.0 那么请尽量使用新的语法；")])]),e._v(" "),r("h2",{attrs:{id:"onrendertracked和onrendertriggered函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#onrendertracked和onrendertriggered函数"}},[e._v("#")]),e._v(" onRenderTracked和onRenderTriggered函数")]),e._v(" "),r("blockquote",[r("p",[e._v("供开发时使用\nonRenderTracked直译过来就是状态跟踪，它会跟踪页面上所有响应式变量和方法的状态，也就是我们用return返回去的值，他都会跟踪。只要页面有update的情况，他就会跟踪，然后生成一个event对象，我们通过event对象来查找程序的问题所在。\nonRenderTriggered直译过来是状态触发，它不会跟踪每一个值，而是给你变化值的信息，并且新值和旧值都会给你明确的展示出来。\n如果把onRenderTracked比喻成散弹枪，每个值都进行跟踪，那onRenderTriggered就是狙击枪，只精确跟踪发生变化的值，进行针对性调试。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);