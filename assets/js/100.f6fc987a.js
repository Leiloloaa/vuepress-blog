(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{559:function(e,a,n){"use strict";n.r(a);var p=n(35),s=Object(p.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"说说你对-webpack-的看法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#说说你对-webpack-的看法"}},[e._v("#")]),e._v(" 说说你对 webpack 的看法")]),e._v(" "),n("p",[e._v("webpack 是一个用于现代 JavaScript 应用程序的静态模块(这里的静态模块指的是开发阶段，可以被 webpack 直接引用的资源)打包工具。")]),e._v(" "),n("p",[e._v("webpack 的能力")]),e._v(" "),n("ul",[n("li",[e._v("将 es6 => es5 解决兼容性问题，通过 babel")]),e._v(" "),n("li",[e._v("模块整合，将 js 文件放在同一个 bundle.js 下")]),e._v(" "),n("li",[e._v("万物都可打包，会有相应的 loader 进行打包")])]),e._v(" "),n("h2",{attrs:{id:"webpack-的构建流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的构建流程"}},[e._v("#")]),e._v(" webpack 的构建流程")]),e._v(" "),n("ul",[n("li",[e._v("初始化流程\n"),n("ul",[n("li",[e._v("读取配置文件中的参数")])])]),e._v(" "),n("li",[e._v("入口文件开始编译")]),e._v(" "),n("li",[e._v("根据配置文件中的 loader 去处理匹配的文件")]),e._v(" "),n("li",[e._v("得到处理后的文件，生成 ast 语法树")]),e._v(" "),n("li",[e._v("再处理依赖关系")]),e._v(" "),n("li",[e._v("输出文件")])]),e._v(" "),n("h2",{attrs:{id:"webpack-的打包原理是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的打包原理是什么"}},[e._v("#")]),e._v(" Webpack 的打包原理是什么？")]),e._v(" "),n("p",[e._v("webpack 是一个现代 JavaScript 应用程序的静态模块打包器。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。")]),e._v(" "),n("p",[e._v("自己实现了一个 mini-webpack 80 多行代码")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("根据 文件 关系 生成 图 graph")]),e._v(" "),n("ul",[n("li",[e._v("内容")]),e._v(" "),n("li",[e._v("依赖关系\n"),n("ul",[n("li",[e._v("通过 babel 的 traverse")])])])])]),e._v(" "),n("li",[n("p",[e._v("然后再根据 图 生成 js")]),e._v(" "),n("ul",[n("li",[e._v("ejs 模板")]),e._v(" "),n("li",[e._v("考虑重名与文件相对路径问题")])])]),e._v(" "),n("li",[n("p",[e._v("解析入口文件，生成 AST 使用 babel/parser`")])]),e._v(" "),n("li",[n("p",[e._v("再使用 babel/traverse 找到入口文件的依赖")])]),e._v(" "),n("li",[n("p",[e._v("再遍历递归所有的依赖并转换为 code")])]),e._v(" "),n("li",[n("p",[e._v("合并递归关系，输出到 bundle 中")])])]),e._v(" "),n("h2",{attrs:{id:"什么是-loader-什么是-plugin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是-loader-什么是-plugin"}},[e._v("#")]),e._v(" 什么是 loader，什么是 plugin？")]),e._v(" "),n("p",[e._v("webpack 默认只识别 js 文件，对于例如 json 格式的文件，我们需要用相应的 loader 去转换再形成 ast 语法树。而 plugin 是为了解决 loader 无法实现的事情，plugin 能提供特定的功能。")]),e._v(" "),n("p",[e._v("常用的 HtmlWebpackPlugin 插件：在打包结束后，⾃动生成⼀个 html ⽂文件，并把打包生成的 js 模块引⼊到该 html 中。")]),e._v(" "),n("ul",[n("li",[e._v("loader 是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中")]),e._v(" "),n("li",[e._v("plugin 赋予了 webpack 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 loader 无法实现的其他事")])]),e._v(" "),n("p",[n("strong",[e._v("两者在运行时机上的区别：")])]),e._v(" "),n("ul",[n("li",[e._v("loader 运行在打包文件之前")]),e._v(" "),n("li",[e._v("plugins 在整个编译周期都起作用")])]),e._v(" "),n("p",[e._v("在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过Webpack提供的 API 改变输出结果。对于loader，实质是一个转换器，将A文件进行编译形成B文件，操作的是文件，比如将 A.scss 或 A.less 转变为 B.css，单纯的文件转换过程。")]),e._v(" "),n("h2",{attrs:{id:"什么是热更新-有什么优点"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是热更新-有什么优点"}},[e._v("#")]),e._v(" 什么是热更新？有什么优点？")]),e._v(" "),n("p",[e._v("HMR 全称 Hot Module Replacement，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用。")]),e._v(" "),n("p",[e._v("例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失。如果使用的是 HMR，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用。")]),e._v(" "),n("p",[n("strong",[e._v("开启热更新")])]),e._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" webpack "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("require")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'webpack'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\nmodule"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("exports "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// ...")]),e._v("\n  devServer"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 开启 HMR 特性")]),e._v("\n    hot"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// hotOnly: true")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br")])]),n("h2",{attrs:{id:"如何借助-webpack-来优化前端性能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何借助-webpack-来优化前端性能"}},[e._v("#")]),e._v(" 如何借助 webpack 来优化前端性能？")]),e._v(" "),n("p",[e._v("通过webpack优化前端的手段有：")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("代码压缩")]),e._v(" "),n("ul",[n("li",[e._v("JS代码压缩")]),e._v(" "),n("li",[e._v("CSS代码压缩")]),e._v(" "),n("li",[e._v("HTML文件代码压缩")])])]),e._v(" "),n("li",[n("strong",[e._v("文件大小压缩")])]),e._v(" "),n("li",[n("strong",[e._v("图片压缩")])]),e._v(" "),n("li",[n("strong",[e._v("Tree Shaking")])]),e._v(" "),n("li",[n("strong",[e._v("代码分离")])]),e._v(" "),n("li",[n("strong",[e._v("内联 chunk")])])]),e._v(" "),n("p",[e._v("webpack 提高构建速度的方式\nloader 输入什么产出什么 ？\nwebpack 原理\nwebpack 动态加载的原理\nwebpack 热更新\n如何写一个 webpack plugin\nAST 的应用\n如何解析一个 html 文本，还是考 AST\nbabel 原理，怎么写 babel 插件\n如何设计一个沙盒 sandbox ？\n小程序的 API 做了什么处理，能够做到全局变量的隐藏，如果是你，怎么设计 ？")]),e._v(" "),n("h1",{attrs:{id:"你说你懂-webpack-那你来讲一下原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#你说你懂-webpack-那你来讲一下原理"}},[e._v("#")]),e._v(" 你说你懂 webpack，那你来讲一下原理")]),e._v(" "),n("p",[e._v("对于面对简历面试的我来说，要深扣写在简历上的每一个字眼。既然说了会，就得准备一些原理性的东西。")]),e._v(" "),n("p",[e._v("知道babel么\n可以实现将ES6编译为ES5代码")]),e._v(" "),n("h2",{attrs:{id:"原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),n("ul",[n("li",[e._v("首先解析入口文件"),n("code",[e._v("entry")]),e._v("，将其转为"),n("code",[e._v("AST(抽象语法树)")]),e._v("，过程中使用插件"),n("code",[e._v("@babel/parser")])]),e._v(" "),n("li",[e._v("再使用"),n("code",[e._v("@babel/traverse")]),e._v("去找出入口文件所有依赖模块")]),e._v(" "),n("li",[e._v("然后使用"),n("code",[e._v("@babel/core+@babel/preset-env")]),e._v("将入口文件的"),n("code",[e._v("AST")]),e._v("转为"),n("code",[e._v("Code")])]),e._v(" "),n("li",[e._v("将第二步中找到的入口文件的依赖模块，进行遍历递归，重复执行前三步")]),e._v(" "),n("li",[e._v("重写"),n("code",[e._v("require")]),e._v("函数，并与第四步中生成的递归关系图一起，输出到"),n("code",[e._v("bundle")]),e._v("中")])]),e._v(" "),n("p",[e._v("谈谈你对webpack的理解\n是一个对资源进行模块化和打包的工具，处理每个模块的 import 和 export\n追问：资源是指什么？\n回答：Js,css,png图片等\n追问：如果有个二进制文件，它是资源么？webpack怎么使它模块化？\n回答：是。需要有一个对应的loader来处理（我是想到了vue-loader等)")]),e._v(" "),n("h2",{attrs:{id:"webpack-的构建流程是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的构建流程是什么"}},[e._v("#")]),e._v(" webpack 的构建流程是什么")]),e._v(" "),n("p",[e._v("初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配 对置的参数,形成最后的配置结果；")]),e._v(" "),n("p",[e._v("开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件 监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译；")]),e._v(" "),n("p",[e._v("确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去；")]),e._v(" "),n("p",[e._v("编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；")]),e._v(" "),n("p",[e._v("完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry或分包配置生成代码块chunk;")]),e._v(" "),n("p",[e._v("输出完成：输出所有的chunk到文件系统；")]),e._v(" "),n("p",[e._v("webpack 的热更新原理\n其实是自己开启了express应用，添加了对webpack编译的监听，添加了和浏览器的websocket长连接，当文件变化触发webpack进行编译并完成后，会通过sokcet消息告诉浏览器准备刷新。而为了减少刷新的代价，就是不用刷新网页，而是刷新某个模块，webpack-dev-server可以支持热更新，通过生成 文件的hash值来比对需要更新的模块，浏览器再进行热替换")]),e._v(" "),n("p",[e._v("服务端")]),e._v(" "),n("p",[e._v("启动 webpack-dev-server服务器\n创建webpack实例\n创建server服务器\n添加webpack的done事件回调\n编译完成向客户端发送消息\n创建express应用app\n设置文件系统为内存文件系统\n添加 webpack-dev-middleware 中间件\n中间件负责返回生成的文件\n启动webpack编译\n创建http服务器并启动服务\n使用sockjs在浏览器端和服务端之间建立一个websocket长连接\n创建socket服务器客户端\nwebpack-dev-server/client端会监听到此hash消息\n客户端收到ok消息后会执行reloadApp方法进行更新\n在reloadApp中会进行判断，是否支持热更新，如果支持的话发生 webpackHotUpdate事件，如果不支持就直接刷新浏览器\n在 webpack/hot/dev-server.js 会监听 webpackHotUpdate 事件\n在check方法里会调用module.hot.check方法\nHotModuleReplacement.runtime请求Manifest\n通过调用 JsonpMainTemplate.runtime 的 hotDownloadManifest方法\n调用JsonpMainTemplate.runtime的hotDownloadUpdateChunk方法通过JSONP请求获取最新的模块代码\n补丁js取回来或会调用 JsonpMainTemplate.runtime.js 的 webpackHotUpdate 方法\n然后会调用 HotModuleReplacement.runtime.js 的 hotAddUpdateChunk方法动态更新 模块代码\n然后调用hotApply方法进行热更\nwebpack 打包是hash码是如何生成的\n1.webpack生态中存在多种计算hash的方式")]),e._v(" "),n("p",[e._v("hash\nchunkhash\ncontenthash\nhash代表每次webpack编译中生成的hash值，所有使用这种方式的文件hash都相同。每次构建都会使webpack计算新的hash。chunkhash基于入口文件及其关联的chunk形成，某个文件的改动只会影响与它有关联的chunk的hash值，不会影响其他文件contenthash根据文件内容创建。当文件内容发生变化时，contenthash发生变化")]),e._v(" "),n("p",[e._v("2.避免相同随机值")]),e._v(" "),n("p",[e._v('webpack在计算hash后分割chunk。产生相同随机值可能是因为这些文件属于同一个chunk,可以将某个文件提到独立的chunk（如放入entry）\nwebpack 离线缓存静态资源如何实现\n在配置webpack时，我们可以使用html-webpack-plugin来注入到和html一段脚本来实现将第三方或者共用资源进行 静态化存储在html中注入一段标识，例如 <% HtmlWebpackPlugin.options.loading.html %> ,在 html-webpack-plugin 中即可通过配置html属性，将script注入进去\n利用 webpack-manifest-plugin 并通过配置 webpack-manifest-plugin ,生成 manifestjson 文件，用来对比js资源的差异，做到是否替换，当然，也要写缓存script\n在我们做Cl以及CD的时候，也可以通过编辑文件流来实现静态化脚本的注入，来降低服务器的压力，提高性能\n可以通过自定义plugin或者html-webpack-plugin等周期函数，动态注入前端静态化存储script\nwebpack 常见的plugin有哪些\nProvidePlugin：自动加载模块，代替require和import\nhtml-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件\nextract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件\nDefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。\nHotModuleReplacementPlugin 热更新\noptimize-css-assets-webpack-plugin 不同组件中重复的css可以快速去重\nwebpack-bundle-analyzer 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示。\ncompression-webpack-plugin 生产环境可采用gzip压缩JS和CSS\nhappypack：通过多进程模型，来加速代码构建\nclean-wenpack-plugin 清理每次打包下没有使用的文件\nspeed-measure-webpack-plugin:可以看至U每个Loader和Plugin执行耗时（整个扌丁包耗时、每个Plugin和 Loader 耗时）\nwebpack-bundle-analyzer:可视化Webpack输出文件的体积（业务组件、依赖第三方模块\nwebpack 插件如何实现\nwebpack本质是一个事件流机制，核心模块：tabable(Sync + Async)Hooks 构造出 === Compiler(编译) + Compiletion(创建bundles)\ncompiler对象代表了完整的webpack环境配置。这个对象在启动webpack时被一次性建立，并配置好所有可操作的设置，包括options、loader和plugin。当在webpack环境中应用一插件时，插件将收到此compiler对象的引用。可以使用它来访问webpack的主环境\ncompilation对象代表了一次资源版本构建。当运行webpack开发环境中间件时，每当检测到一个文件变化，就会创建一个新的compilation,从而生成一个新的编译资源。一个compilation对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态的信息。compilation对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用\n创建一个插件函数，在其prototype上定义apply方法，指定一个webpack自身的事件钩子\n函数内部处理webpack内部实例的特定数据\n处理完成后，调用webpack提供的回调函数\nfunction MyWebpackPlugin()(\n}；\n// prototype 上定义 apply 方法\nMyWebpackPlugin.prototype.apply=function(){\n// 指定一个事件函数挂载到webpack\ncompiler.pluginCwebpacksEventHook"funcion (compiler)( console. log(“这是一个插件”)；\n// 功能完成调用后webpack提供的回调函数\ncallback()\n})\nwebpack有哪些常⻅的Loader\nfile-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件\nurl-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去\nsource-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试\nimage-loader：加载并且压缩图⽚⽂件\nbabel-loader：把 ES6 转换成 ES5\ncss-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性\nstyle-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。\neslint-loader：通过 ESLint 检查 JavaScript 代码\nwebpack如何实现持久化缓存\n服务端设置http缓存头（cache-control）\n打包依赖和运行时到不同的chunk，即作为splitChunk,因为他们几乎是不变的\n延迟加载：使用import()方式，可以动态加载的文件分到独立的chunk,以得到自己的chunkhash\n保持hash值的稳定：编译过程和文件内通的更改尽量不影响其他文件hash的计算，对于低版本webpack生成的增量数字id不稳定问题，可用hashedModuleIdsPlugin基于文件路径生成解决\n如何⽤webpack来优化前端性能？\n⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。')]),e._v(" "),n("p",[e._v("压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css\n利⽤CDN加速: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径\nTree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现\nCode Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存\n提取公共第三⽅库: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码\nwebpack treeShaking机制的原理\ntreeShaking 也叫摇树优化，是一种通过移除多于代码，来优化打包体积的，生产环境默认开启。\n可以在代码不运行的状态下，分析出不需要的代码；\n利用es6模块的规范\nES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块\n静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码原型链\n继承\n闭包\nes6\nthis指向\n作用域\n事件循环\n事件流\n缓存相关\nhttp相关\n前端模块化\n浏览器渲染相关\ncss相关\n第二阶段 主要为原理和偏深度的考察学习 包含但不仅限以下")]),e._v(" "),n("p",[e._v("React源码\nVue源码\n算法和手写编程题\n性能优化\nWebpack相关\ngit高级操作\n操作系统\n前端微服务\n设计模式\ncss高级\n第三阶段 主要针对个人项目难点和亮点的深挖，助你讲好项目说出亮点")]),e._v(" "),n("p",[e._v("第四阶段 人事面试 Hr谈薪技巧和套路")])])}),[],!1,null,null,null);a.default=s.exports}}]);